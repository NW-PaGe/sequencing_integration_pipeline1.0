{
  "hash": "2763cc6abfd2f3d6255b2b9eac4ad5c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Dashboard\"\nauthor: \"Emily Nebergall and Allie Warren\"\ndate: \"2024-03-01\"\noutput: html_document\n---\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nknitr::opts_chunk$set(eval = FALSE)\n```\n:::\n\n\n\n\n\n\n\n# Overview\n\nThe PHL COVID-19 dashboard posts results of COVID-19 RT-PCR tests and sequencing. Some of the specimens in the PHL sequencing dashboard were tested and sequenced at the PHL, others were tested at other labs and the specimen was shipped to PHL for sequencing. Specimens that are tested and sequenced can be matched to WDRS using the SpecimenID in the sequencing dashboard. Matching data for specimens from other laboratories are located on the REDCap or Surveillance dashboard. The REDCap specimens are assigned a WA number when they arrive at the lab for sequencing, but this WA number is not usually in WDRS. These specimens also have an AccessionNumber, which contains the clinical identifier tied to the specimen at its originating lab, but this ID can sometimes link to other records in WDRS, therefore RedCap records are sent to fuzzy matching for record linkage. The Surveillance specimens can often be matched to WDRS by the AccessionId column in the Surveillance dashboard, which contains the clinical identifier tied to the specimen at its originating lab.\n\nThis script is run after downloading the data using the sel_Dashboard_All.Rmd script, and reads in found files downloaded from the PHL COVID-19 dashboard: the PHL sequencing dashboard file, the accompanying REDCAp viewer file, the Surveillance viewer file, and the Epi (All Specimens) dashboard, which contains additional name and DOB info. It matches specimens to WDRS CASE_ID's first using the WA number in the SpecimenID column of the PHL dashboard as the sequence clinical accession. It then uses the SpecimenID to find the AccessionId from the Surveillance file for sequenced specimens, and attempts to match the sequence data to a WDRS CASE_ID using the AccessionId as the sequence clinical accession. The SpecimenID and AccessionId are matched to [FILLER\\_\\_ORDER\\_\\_NUM] in the ELR Entire table of WDRS.\n\nIf a specimen cannot be matched using a sequence clinical accession number, then it is split out from the rest of the data and printed in a file to be matched to WDRS using demographic data in a separate FUZZY_MATCHING script, or, if it lacks demographic information, it is sent to the keep_na list.\n\nQuality filters are applied at multiple stages of the script. Columns for sequence reason, sequence status, sequence accession are checked to make sure they contain only values that we expect to see. The script also checks that the Collected Date column is in the expected format and that the specimen collected date is not off by more than 14 days from the collected date in WDRS, and that other fields follow the expected format. These checks are contained in the roster_filters function within the quality_filters script. Some data that is filtered out in these various checks are sent to For_Review, so that errors can be addressed and the data can be rostered.\n\nRows that contain a sequence accession number already found in WDRS are removed from the data as early as possible to reduce the workload of the rest of the script. Records are also checked to see if they have already been processed by the script. Data from PHL is cumulative, meaning that new records need to be separated out from records that have already been processed so that duplicates are not written to output folders. A running list of all of the sequence accessions (or Seq IDs as they are sometimes referred) that have been processed by the script is kept, and used to identify records that are new. A sequence accession is assigned for all PHL records (even if the sequencing fails), even though only sequence accessions associated with complete sequencing are uploaded to WDRS, and can therefore be used to track records.\n\n# Setup {.tabset}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(lubridate)\n\nrenv::load(file.path(Sys.getenv(\"USERPROFILE\"),\"Projects/Sequencing/\"))\n\nif (wday(today()) %in% c(2, 3, 4)){\n  try(\n    rmarkdown::render(file.path(Sys.getenv(\"USERPROFILE\"),\n                                \"Projects/Sequencing/Roster_scripts\",\n                                \"sel_Dashboard_All.Rmd\"),\n                    output_file=file.path(Sys.getenv(\"USERPROFILE\"),\n                                \"Projects/Sequencing/Roster_scripts\",\n                                \"sel_Dashboard_All.html\")),\n    stop(\"Selenium script failed\")\n  )\n}\n```\n:::\n\n\n\n\n\n## Load all libraries\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\nlibrary(here)\nlibrary(lubridate)\nlibrary(readxl)\nlibrary(DBI)\nlibrary(odbc)\nlibrary(dtplyr)\nlibrary(fs)\n```\n:::\n\n\n\n\n\n\n## Load Data Objects and Files\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# read in r_creds.RDS\nr_creds <-readRDS(file.path(Sys.getenv(\"USERPROFILE\"), \"Projects/Sequencing/Data_Objects\", \"r_creds.RDS\"))\n\n# read in sequence reasons and lab names\nlab_vars <- readRDS(\"/Data_Objects/lab_variables.rds\")\n\n# load list of all valid lineages\nlineages <- read_csv(\"Data_Objects/Lineages/Lineages.csv\")\n\n# Read in quality_filters\nsource(file.path(Sys.getenv(\"USERPROFILE\"), \"Projects/Sequencing/Roster_scripts/quality_filters.R\"))\n\n# Extract a list of valid lineages from the lineages_list object (this should be updated daily via an automated script)\n  # Append \"\" and NA, as records with a LOW QUALITY or FAILED sequence status will not contain lineage information\nlineages_list <- c(\n  lineages[[1]], \n  \"Unassigned\"\n)\n\n# Get PHL input sequence reasons that do not have a corresponding reason in the list of output reasons\n# Records with one of these reasons will be filtered out of the final roster and, potentially, sent for review\n# PT is an expected output here, as records with that reason are not added to the roster\nunmatched_seq_reasons <- lab_vars$phl_seq_reasons[setdiff(seq(1:length(lab_vars$phl_seq_reasons)), seq(1:length(lab_vars$output_seq_reasons_phl)))]\n\nprint(unmatched_seq_reasons)\n\n# maximum number of rows used to identify the type of each column when reading data in\n# number can be larger than the number of rows in the data - it is currently set to be larger than any of the data sets\n# if too small, read_xlsx may incorrectly infer the column type, causing it to not read in all the data\ntype_n_rows <- 100000\n\n\n# list of PHL records that have already been processed\nphl_processed_records <- read_csv(\"/Completed_Submissions/PHL_Records/phl_processed_records.csv\")\n\n# list used to store records currently being processed\nnew_records <- c()\n```\n:::\n\n\n\n\n\n\n# Load Input Data {.tabset}\n\n## PHL Data\n\nThe primary PHL dashboard that contains most of the relevant columns used to create the PHL roster\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# get filepath for files containing PHL_20 in the PHL Submissions folder\nphl_filename <- dir_ls(\"Submissions/PHL\",\n                       type = 'file'\n                       ) %>%\n  str_subset(\"PHL/PHL_20\")\n\n# stop script if no PHL file\nif(length(phl_filename) == 0){\n   stop(\"No PHL file in Submissions/PHL folder\")\n}\n\n# throw warning if there is more than one PHL file, then take the most recent file\n# and continue\nif (length(phl_filename) > 1){\n  print(\"More than one PHL file, selecting just the most recent file\")\n  \n  # get the file with the most recent mtime:\n  phl_filename <- phl_filename[file.mtime(phl_filename) == max(file.mtime(phl_filename))]\n}\n\n# define the list of columns of interest from the PHL dashboard\nphl_columns <- c(\"Seq ID\", \"SpecimenId\", \"Sequencing Result\", \"Reason\", \"Collected Date\", \"Lineage\") \n\n# read in PHL file, only including selected files\nphl <- read_xlsx(phl_filename, guess_max = type_n_rows,\n                 na = c(\"\", \"NA\", \"N/A\")) %>%\n  select(all_of(phl_columns))\n```\n:::\n\n\n\n\n\n\n## REDCAP Data\n\nData from the RedCap dashboard\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# get filepath for files containing REDCAP in the PHL Submissions folder\nredcap_filename <- dir_ls(\"Submissions/PHL\") %>%\n  str_subset(\"REDCAP\")\n\n# stop script if no REDCAP file\nif(length(redcap_filename) == 0){\n   stop(\"No REDCAP file in Submissions/PHL folder\")\n}\n\n# throw warning if there is more than one REDCAP file, then take the most recent file\n# and continue\nif (length(redcap_filename) > 1){\n  print(\"More than one REDCAP file, selecting just the most recent file\")\n  \n  # get the file with the most recent mtime:\n  redcap_filename <- redcap_filename[file.mtime(redcap_filename) == max(file.mtime(redcap_filename))]\n}\n\n\n# read in REDCAP file\nredcap <- read_xlsx(redcap_filename, guess_max = type_n_rows) %>%\n  filter(!is.na(SpecimenId)) \n```\n:::\n\n\n\n\n\n\n\n## Surveillance Data\n\nSentinel Surveillance Samples\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# get filepath for files containing Surveillance in the PHL Submissions folder\nsurveillance_filename <- dir_ls(\"Submissions/PHL\") %>%\n  str_subset(\"Surveillance\")\n\n# stop script if no Surveillance file\nif(length(surveillance_filename) == 0){\n   stop(\"No Surveillance file in Submissions/PHL folder\")\n}\n\n# throw warning if there is more than one Surveillance file, then take the most recent file\n# and continue\nif (length(surveillance_filename) > 1){\n  print(\"More than one Surveillance file, selecting just the most recent file\")\n  \n  # get the file with the most recent mtime:\n  surveillance_filename <- surveillance_filename[file.mtime(surveillance_filename) == max(file.mtime(surveillance_filename))]\n}\n\n# read in Surveillance file\nsurveillance <- read_xlsx(surveillance_filename, guess_max = type_n_rows) %>%\n  filter(!is.na(SpecimenId)) \n```\n:::\n\n\n\n\n\n\n## Epi Data\n\nThe Epi (All Specimens) dashboard that contains name and DOB for more records\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# get filepath for files containing Epi in the PHL Submissions folder\nepi_filename <- dir_ls(\"Submissions/PHL\", \n                       type = 'file'\n                       ) %>%\n  str_subset(\"Epi\")\n\n# stop script if no Epi file\nif(length(epi_filename) == 0){\n   stop(\"No Epi file in Submissions/PHL folder\")\n}\n\n# throw warning if there is more than one Epi file, then take the most recent file\n# and continue\nif (length(epi_filename) > 1){\n  print(\"More than one Epi file, selecting just the most recent file\")\n  # get the file with the most recent mtime:\n  epi_filename <- epi_filename[file.mtime(epi_filename) == max(file.mtime(epi_filename))]\n}\n\n\n\n# read in epi file, only selecting relevant columns\nepi <- read_xlsx(epi_filename, guess_max = type_n_rows,\n                 na = c(\"\", \"NA\", \"N/A\")) %>%\n  select(`Specimen ID`, `First Name`, `Last Name`, `Birth Date`)\n```\n:::\n\n\n\n\n\n\n# Initial quality checks {.tabset}\n\n## Work Stoppers\n\nThese errors will prompt the script to stop running\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Check for empty columns within the PHL input, and stop script if a column is empty\n# Empty column may indicate that the input file was not properly downloaded or\n# an error occurred when reading in the file\n\nstop_script <- function(x) {\n  if (any(!is.na(phl[ ,x])) == FALSE) {\n    stop(paste0(x, \" column in the phl file is empty\"))\n  }\n}\n\n\nlapply(phl_columns, stop_script)\n```\n:::\n\n\n\n\n\n\n## Warning Generators\n\nSome errors warrant a warning but are not work stoppers. These should generate an alert that something has changed with the PHL data and we should contact PHL or molecular epi to ask for new mappings or an explanation of the meaning of the new conditions observed in the data.\n\nCheck for unexpected values or major changes to the data that invalidate it for processing via this script. PHL Reason \"Outbreak Investigation\" rows are mapped to \"OUTBREAK\" later in this script. PT (which stands for \"proficiency test\") rows are later dropped from the data.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# expected conditions\n\nmapped_status <- c(\"COMPLETED {1822}\", \"FAILED {1823}\", NA)\n\n# conditions observed in data downloaded from dashboard\n\nphl_reasons <- str_trim(toupper(unique(phl$Reason)))\n\nphl_status <- str_trim(toupper(unique(phl$`Sequencing Result`)))\n\n\n# check that phl conditions match mapped conditions\nnew <- c()\nreason_messages <- c()\nstatus_messages <- c()\n\n\n# Report new sequence reasons\nif(any(!(phl_reasons %in% lab_vars$phl_seq_reasons) == TRUE)) {\n  new <- setdiff(phl_reasons, lab_vars$phl_seq_reasons)\n  \n  if (length(new) > 0) {\n    for (i in 1:length(new)) {\n      reason_messages[i] <-\n        paste0(\n          new[i],\n          \" is an unmapped sequence reason found in the Reason column of the PHL COVID-19 dashboard today\"\n        )\n    }\n  }\n}\n\n\n# Report new sequence status not found in expected list\nif(any(!(phl_status %in% mapped_status) == TRUE)) {\n  new <- setdiff(phl_status, mapped_status)\n  \n  if (length(new) > 0) {\n    for (i in 1:length(new)) {\n      status_messages[i] <-\n        paste0(\n          new[i],\n          \" is an unmapped sequence status found in the Sequencing Result column of the PHL COVID-19 dashboard today\"\n        )\n    }\n  }\n}\n\n# check that the format of the Collected Date column is the expected format\n\ndate_messages <- c()\n\nif(any(str_detect(phl$`Collected Date`, \"(?<=2020|2021)-[[:digit:]]{1,12}-[[:digit:]]{1,31}\")) != TRUE) {\n  date_messages <- \"The Collected Date column has one or more dates that do not follow the expected format\"\n}\n\n\n\nwarnings <- c(reason_messages, status_messages, date_messages)\n\nwarnings\n```\n:::\n\n\n\n\n\n\n# WDRS Queries {.tabset}\n\n## Open  WDRS Connection \n\n**IMPORTANT** the variables used to connect to WDRS are held within conn_list.RDS. All .RDS objects in this repository except for VOC.RDS are excluded from Git commits by declaring *.RDS in the .gitignore file because they are often used to hold our \"secrets\" such as credential and server connections. \n\nWe do not include server connections in code uploaded to GitHub. **WHY?** We have been asked by HTS to ensure our use of GitHub does not raise any security red flags. This server is an internal server containing confidential/restricted PHI. We want to hide this server information to reduce our possible “attack surface”. This connection may seem benign but it tells someone information they can use to \"hack\" into WDRS. SQL Server Native Client is now deprecated software and version 11 was the last release. Unsupported software is at higher risk of having security breaches. Additionally, someone would know the server name. \n\n**So: DO NOT alter the code used to open the connection to WDRS in any way that creates a security risk. Continue to treat this connection as a secret and store its variables in a .RDS object (or other external object that is excluded from Git commits) rather than calling them directly here.**\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# connect\nconnection <- DBI::dbConnect(odbc::odbc(), \n                             Driver = r_creds$conn_list[1], \n                             Server = r_creds$conn_list[2], \n                             Database = r_creds$conn_list[3], \n                             Trusted_connection = r_creds$conn_list[4], \n                             ApplicationIntent = r_creds$conn_list[5])\n```\n:::\n\n\n\n\n\n\n## WDRS FLATTENED\n\nThis queries the flattened table and provides a list of unique sequence accessions and sequence clinical accessions that we use to avoid adding duplicate data to the final roster.\n\n### Flattened Sequence Accessions\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Query WDRS flattened table\n# result is saved to cache - this is useful for testing the code, but\n# when running not in test code cached data will first be deleted\n#wdrs_sa_flat <- xfun::cache_rds({\n  # wdrs_sa_flat <- dbGetQuery(\n  #   connection,\n  #   \"SELECT DISTINCT CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n  #    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER\n  #    FROM [dbo].[DD_GCD_COVID_19_FLATTENED]\n  #    \"\n  # )\n\nwdrs_sa_flat <- dbGetQuery(connection,\n                        \"\n    SELECT SEQUENCE_ACCESSION_NUMBER, SEQUENCE_CLINICAL_ACCESSION_NUMBER\n    FROM DD_GCD_COVID19_SEQUENCING\n    WHERE SEQUENCE_SPECIMEN IS NOT NULL\n    AND CASE_STATUS IN (0, 3)\n    ORDER BY SEQUENCE_ROSTER_PREPARE_DATE DESC;\n                       \")\n#},\n#file = \"wdrs_sa_flat\")\n\n# for fields that have multiple comma separated SEQUENCE_ACCESSIONs split them by \",\"\n# wdrs_sa_flat_split <- unlist(str_split(wdrs_sa_flat[[1]], \",\"))\n  \n# omit any NA's\nwdrs_sa_flat_clean <-\n    wdrs_sa_flat$SEQUENCE_ACCESSION_NUMBER[!is.na(wdrs_sa_flat$SEQUENCE_ACCESSION_NUMBER)] %>%\n    #for fields that have \"hCoV-19/\" appended to the beginning of the SEQUENCE_ACCESSION remove it by str_replace() with \"\"\n    str_replace(\"hCoV-19/\", \"\") %>%\n    # trim off the white space resulting from str_split, this also gets rid of \" \" values\n    str_trim(\"both\")\n  \n# remove any values that are \"\"\nwdrs_sa_flat_values <- wdrs_sa_flat_clean[wdrs_sa_flat_clean != \"\"]\n```\n:::\n\n\n\n\n\n\n### Flattened Sequence Clinical Accessions\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# for fields that have multiple comma separated SEQUENCE_CLINICAL_ACCESSIONs split them by \",\"\n# wdrs_sca_flat_split <- unlist(str_split(wdrs_sa_flat[[2]], \",\"))\n\n# omit any NA's\nwdrs_sca_flat_clean <- wdrs_sa_flat$SEQUENCE_CLINICAL_ACCESSION_NUMBER[!is.na(wdrs_sa_flat$SEQUENCE_CLINICAL_ACCESSION_NUMBER)] %>%\n#for fields that have \"hCoV-19/\" appended to the beginning of the SEQUENCE_CLINICAL_ACCESSION remove it by str_replace() with \"\"\n  str_replace(\"hCoV-19/\", \"\") %>%\n# trim off the white space resulting from str_split, this also gets rid of \" \" values  \n  str_trim(\"both\")\n\n# remove any values that are \"\"\nwdrs_sca_flat_values <- wdrs_sca_flat_clean[wdrs_sca_flat_clean != \"\"]\n```\n:::\n\n\n\n\n\n\n## WDRS ENTIRE\n\nPull COVID-19 records from the WDRS ENTIRE and LAB tables.\nThe sequence clinical accession numbers and specimen collection date\nare used to match new sequencing data to WDRS.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Query WDRS ELR Entire Table\n# result is saved to cache - this is useful for testing the code, but\n# when running not in test code cached data will first be deleted\n#wdrs_seq <- xfun::cache_rds({\n  wdrs_seq <- dbGetQuery(\n    connection,\n    \"\n  SELECT Distinct CASE_ID,\n    [FILLER__ORDER__NUM] as SpecimenId,\n    [SPECIMEN__ID__ACCESSION__NUM__MANUAL] as SPECIMEN_ID,\n    [SPECIMEN__COLLECTION__DTTM] as COLLECTION_DATE_WDRS\n    FROM [dbo].[DD_ELR_DD_ENTIRE]\n  WHERE CODE = 'SARS'\n  AND STATUS != '6'\n  \"\n  )\n  \n  wdrs_seq <-\n  wdrs_seq %>% unite(\n    SpecimenId,\n    c(SpecimenId, SPECIMEN_ID),\n    sep = \",\",\n    remove = FALSE,\n    na.rm = TRUE\n  )\n#},\n#file = \"wdrs_seq\")\n```\n:::\n\n\n\n\n\n\n## WDRS LAB\n\nAdditional cases to match may be found in the COVID19 lab table. This is especially true for redcap cases.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Query WDRS lab table\n# result is saved to cache - this is useful for testing the code, but\n# when running not in test code cached data will first be deleted\n\n#wdrs_lab_cases <-\n  #xfun::cache_rds({\n    wdrs_lab_cases <-  dbGetQuery(\n      connection,\n      \"SELECT Distinct CASE_ID, [FILLER__ORDER__NUM] as FILLER_ORDER_NUM,\n                             [SPECIMEN__ID__ACCESSION__NUM__MANUAL] as SPECIMEN_ID,\n                             [SPECIMEN__COLLECTION__DTTM] as COLLECTION_DATE_WDRS\n                             FROM [dbo].[DD_GCD_COVID19_LAB]\"\n    )\n    \n    \n    wdrs_lab_cases <-\n      wdrs_lab_cases %>% unite(\n        SpecimenId,\n        c(FILLER_ORDER_NUM, SPECIMEN_ID),\n        sep = \",\",\n        remove = FALSE,\n        na.rm = TRUE\n      )\n  #},\n  #file = \"wdrs_lab_cases\")\n```\n:::\n\n\n\n\n\n\n## Combine WDRS Records\n\nCombine all COVID19 records from WDRS\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# combine WDRS entire and lab tables\nwdrs_all_cases <-\n  full_join(wdrs_lab_cases, wdrs_seq) %>% select(CASE_ID, SpecimenId, COLLECTION_DATE_WDRS)\n\n# Remove  samples from wdrs where the case id and specimen id are duplicated, keeping only the first instance\nunique_wdrs <-\n   wdrs_all_cases[!duplicated(wdrs_all_cases[,c(\"CASE_ID\", \"SpecimenId\")]), ]\n```\n:::\n\n\n\n\n\n\n# Filters and Transformations {.tabset}\n\nA new data frame phl_clean is generated from phl raw data.\n\nThe sequence result and Seq ID columns are transformed to the WDRS roster format. The data is filtered to remove rows that are missing a sequence result (these are incomplete), or that have a Seq ID that has already been entered in the flattened table as a sequence accession. The data is filtered to remove rows with a Sequencing Reason of PT.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Clean up/simplify Sequencing Result and Seq ID columns\n# Remove samples with the sequencing reason PT\nphl_clean <- phl %>%\n  mutate(\n    # Format Sequencing Result\n    `Sequencing Result` = case_when(\n      toupper(`Sequencing Result`) == \"COMPLETED {1822}\" ~ \"COMPLETE\",\n      toupper(`Sequencing Result`) == \"FAILED {1823}\" ~ \"FAILED\",\n      !(toupper(`Sequencing Result`) %in% c(\"COMPLETED {1822}\", \"FAILED {1823}\")) &\n        !is.na(phl$`Sequencing Result`) ~ phl$`Sequencing Result`\n    )\n  ) %>%\n  # adjust format of Seq ID (Sequence Accession)\n  mutate(`Seq ID` = ifelse(\n    str_detect(`Seq ID`, \"hCoV-19/\"),\n    str_replace(`Seq ID`, \"hCoV-19/\", \"\"),\n    `Seq ID`\n  )) %>%\n  # remove records with a sequencing reason of PT\n  filter(!Reason == \"PT\") %>%\n  # only process results that have been sequenced\n  filter(`Sequencing Result` %in% c(\"COMPLETE\", \"FAILED\"))\n\n\n# Remove samples that are already in WDRS\nphl_new <- phl_clean[!(phl_clean$`Seq ID` %in% wdrs_sa_flat_values), ]\n```\n:::\n\n\n\n\n\n\n# Joins {.tabset}\n\n## PHL and REDCap Join\n\nPHL and Redcap data is joined by SpecimenId and ProjectOption is brought into SEQUENCE_REASON in all cases where ProjectOption == \"SENTINEL SURVEILLANCE\". In cases where ProjectOption is other than SENTINEL SURVEILLANCE, the Reason column from the phl sequencing dashboard is retained as SEQUENCE_REASON. All redcap data with demographics will be sent to fuzzy matching.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Join PHL and REDCAP data\ndashboard_all <- left_join(phl_new, redcap, by = \"SpecimenId\") %>% \n  mutate(SEQUENCE_REASON = case_when(\n      toupper(ProjectOption) == \"SENTINEL SURVEILLANCE\" ~ \"SENTINEL SURVEILLANCE\",\n      !(toupper(ProjectOption) == \"SENTINEL SURVEILLANCE\") ~ toupper(Reason),\n      TRUE ~ toupper(Reason)\n    )\n  )\n```\n:::\n\n\n\n\n\n\n## PHL and Surveillance Join\n\nUse specimen id to join the sentinel surveillance to the data from the primary PHL dashboard\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Join Surveillance data with the combined PHL and REDCAP data\ndashboard_all <- left_join(dashboard_all, surveillance, by = \"SpecimenId\")\n```\n:::\n\n\n\n\n\n\n## PHL and Epi Join\n\nUse specimen id to join the Epi (All Specimens) dashboard to PHL dashboard and fill in\nname and data of birth \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Join Epi dashboard to PHL, REDCAP, and Surveillance data\ndashboard_all <- left_join(dashboard_all, epi, by = c('SpecimenId' = 'Specimen ID'))\n\n# If name and dob isn't already present in the data,\n# fill in with data from the Epi (All Specimens) dashboard\ndashboard_all <- dashboard_all %>% \n  mutate(FirstName = ifelse(!is.na(FirstName), FirstName, `First Name`),\n         LastName = ifelse(!is.na(LastName), LastName, `Last Name`),\n         BirthDate = ifelse(!is.na(BirthDate), BirthDate, `Birth Date`)) %>%\n  select(-`First Name`, -`Last Name`, -`Birth Date`)\n```\n:::\n\n\n\n\n\n\n## Join sequence data to WDRS\n\nUse specimen id (sequence clinical accession) to join the PHL specimens to WDRS records\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Join dashboard data with WDRS by Specimen ID (sequence clinical accession), still keeping samples not found in WDRS\njoin_dash_wdrs <-\n  left_join(dashboard_all,\n            unique_wdrs,\n            by = \"SpecimenId\",\n            na_matches = \"never\") \n```\n:::\n\n\n\n\n\n\n## Leftovers\n\nTry to match records not matched with SpecimenId to WDRS using Accession ID from Surveillance.\nRecords without a match are kept in the table and will be passed on to fuzzy matching or\nkeep_na, as relevant.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Select samples where the Specimen ID was not in WDRS\nleftovers <- filter(join_dash_wdrs, is.na(CASE_ID)) %>%\n  select(!CASE_ID) #removes so column can be added back on new join\n\n# Identify samples where the Accession ID is in WDRS, using Surveillance dashboard data\n# Only use the COLLECTION_DATE_WDRS column from unique_wdrs\nleftovers_matching_via_surveillance <- left_join(leftovers %>% select(-COLLECTION_DATE_WDRS), unique_wdrs, \n                                           by = c(\"AccessionId\" = \"SpecimenId\"), na_matches = \"never\") %>% \n  filter(!is.na(CASE_ID), !is.na(AccessionId))\n\n# Remove records that matched on accession id, but include records with no match\njoin_dash_wdrs <- filter(join_dash_wdrs, !AccessionId %in% leftovers_matching_via_surveillance$AccessionId)\n  \n# Recombine all inputs, those with and without matches and select relevant columns\nphl_and_other_matches <-\n  rbind(join_dash_wdrs, leftovers_matching_via_surveillance) %>% select(\n    \"SEQUENCE_REASON\",\n    \"Seq ID\",\n    \"SpecimenId\",\n    \"Sequencing Result\",\n    \"AccessionNumber\",\n    \"AccessionId\",\n    \"CASE_ID\",\n    \"Collected Date\",\n    \"Lineage\",\n    \"COLLECTION_DATE_WDRS\",\n    \"FirstName\",\n    \"LastName\",\n    \"BirthDate\"\n  ) \n```\n:::\n\n\n\n\n\n\n# Transform Data {.tabset}\n\n## Roster Columns\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# rename Seq ID as Sequence_ACCESSION and add variant column\nphl_and_other_matches_clean <- phl_and_other_matches %>%\n  rename(SEQUENCE_ACCESSION = \"Seq ID\") %>%\n  # new free text column for lineage\n  mutate(SEQUENCE_VARIANT_OPEN_TEXT = Lineage)\n```\n:::\n\n\n\n\n\n\n## Sequence Clinical Accession Formats\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Create column for the sequence clinical accession, getting the value from the\n# relevant column for the phl or surveillance data\nphl_and_other_matches_clean <-\n  phl_and_other_matches_clean %>% mutate(\n    SEQUENCE_CLINICAL_ACCESSION = case_when(\n      !is.na(phl_and_other_matches_clean$AccessionId) ~ phl_and_other_matches_clean$AccessionId,\n      TRUE ~ phl_and_other_matches_clean$SpecimenId\n    ))\n```\n:::\n\n\n\n\n\n\n\n## Generate Format for Roster\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Format matched data to fit format for roster\nphl_roster <- phl_and_other_matches_clean %>%\n  # keep track of sequence accession, important for filtering out already processed records\n  mutate(ID = SEQUENCE_ACCESSION) %>%\n  # format collection date\n  mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = as.character(format(\n    as.Date(phl_and_other_matches_clean$`Collected Date`), '%m/%d/%Y' # adjust date to m/d/Y format\n  ))) %>%\n  # format wdrs collection date\n   mutate(COLLECTION_DATE_WDRS = as.character(format(\n    as.Date(phl_and_other_matches_clean$COLLECTION_DATE_WDRS), '%m/%d/%Y'  # adjust date to m/d/Y format\n  ))) %>%\n  # add empty sgtf column\n  mutate(SEQUENCE_SGTF = NA_character_) %>%\n  # add sequence speciment column\n  mutate(SEQUENCE_SPECIMEN = \"YES\") %>%\n  # map input sequence reasons to simplified set of sequence reasons\n  mutate(SEQUENCE_REASON = lab_vars$output_seq_reasons_phl[match(SEQUENCE_REASON, lab_vars$phl_seq_reasons)]) %>%\n  # if the new sequence reason is NA \n  # (meaning it wasn't in the input list or didn't have a mapping to the output list)\n  # return it to the original reason, otherwise keep the new reason\n  # records with sequence reasons not in the accepted output seq reason list will be filtered out\n  mutate(SEQUENCE_REASON = if_else(is.na(SEQUENCE_REASON), phl_and_other_matches_clean$SEQUENCE_REASON, SEQUENCE_REASON)) %>%\n  # add empty sequence date column\n  mutate(SEQUENCE_DATE = NA_character_) %>%\n  # set lab to PHL\n  mutate(SEQUENCE_LAB = \"PHL\") %>%\n  # sequence status column\n  # mutate(SEQUENCE_STATUS = phl_and_other_matches_clean$`Sequencing Result`) %>% \n  # Change all None to Unassigned\n  mutate(SEQUENCE_VARIANT_OPEN_TEXT = if_else(Lineage == \"None\", \"Unassigned\", Lineage)) %>%\n  # Change all Unassigned lineages to have LOW QUALITY status\n  mutate(SEQUENCE_STATUS = case_when(\n    SEQUENCE_VARIANT_OPEN_TEXT == \"Unassigned\" ~ \"LOW QUALITY\",\n    TRUE ~ phl_and_other_matches_clean$`Sequencing Result`\n    )) %>%\n  # If the sequence is FAILED status, leave SEQUENCE_REPOSITORY as null, else set sequence repo to GISAID\n  mutate(SEQUENCE_REPOSITORY = case_when(\n    SEQUENCE_STATUS == \"FAILED\" ~ NA_character_, \n    TRUE ~ \"GISAID\"\n    )) %>%\n  mutate(SEQUENCE_ACCESSION = SEQUENCE_ACCESSION) %>%\n  # add empty sequence reviewed column\n  mutate(SEQUENCE_REVIEWED = NA_character_) %>%\n  # add standard case note\n  mutate(Case.Note = \"External data question package updated by COVID19 Sequencing Roster.\") %>%\n \n  \n\n  # use lineage column to create sequence notes column\n  mutate(SEQUENCE_NOTES = case_when(\n    !is.na(Lineage) & Lineage != \"Unassigned\" ~ paste0(\n      \"Lineage identified as \",\n      phl_and_other_matches_clean$Lineage,\n      \" on \",\n      today(),\n      \". Lineage assignments may change over time.\"\n    ),\n    is.na(Lineage) ~ NA_character_ # Add sequence notes column containing the lineage information\n  )) %>%\n  select(\n    CASE_ID,\n    SEQUENCE_SGTF,\n    SEQUENCE_SPECIMEN,\n    SEQUENCE_REASON,\n    SEQUENCE_DATE,\n    SEQUENCE_LAB,\n    SEQUENCE_STATUS,\n    SEQUENCE_REPOSITORY,\n    SEQUENCE_ACCESSION,\n    SEQUENCE_VARIANT_OPEN_TEXT,\n    SEQUENCE_CLINICAL_ACCESSION,\n    SEQUENCE_SPECIMEN_COLLECTION_DATE,\n    SEQUENCE_NOTES,\n    SEQUENCE_REVIEWED,\n    ID,\n    Case.Note,\n    COLLECTION_DATE_WDRS,\n    # include demographic columns for fuzzy matching\n    FIRST_NAME = FirstName,\n    LAST_NAME = LastName,\n    DOB = BirthDate\n  )\n```\n:::\n\n\n\n\n\n\n# Roster Quality Checks {.tabset}\n\n## Processed Records\n\nFilter out records that have already been processed by the script in past runs\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Remove records that have already been processed\nphl_roster <- filter(phl_roster, !ID %in% phl_processed_records$SEQUENCE_ACCESSION)\n\n\n# Temp addition to change PHL Historic data (2020/2021) to sequence reason \"OTHER\"\nphl_roster <- phl_roster %>% mutate(SEQUENCE_REASON = case_when(\n  str_detect(SEQUENCE_SPECIMEN_COLLECTION_DATE, \"2020$|2021$\") ~ \"OTHER\",\n             TRUE ~ SEQUENCE_REASON))\n```\n:::\n\n\n\n\n\n\n## SCA Failed in WDRS \n\nFilter out records that have a status of FAILED and the sequence clinical accession is already in wdrs\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Remove records that are failed and the SCA is in WDRS\nphl_roster <- filter(phl_roster, !((SEQUENCE_CLINICAL_ACCESSION %in% wdrs_sca_flat_values) & (SEQUENCE_STATUS == 'FAILED')))\n```\n:::\n\n\n\n\n\n\n## Roster Filters\n\nFilter the phl roster and split the data into acceptable rows and rows needing review or exclusion. Print \"bad\" rows to files for review.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# run formatted data through the roster_filters function (from  quality_filters.R) to check for various errors\n# will print how many records have each error type\nphl_quality <- roster_filters(phl_roster, lab_vars, wdrs_sa_flat_values, wdrs_sca_flat_values, lineages_list)\n```\n:::\n\n\n\n\n\n\n\n# Fuzzy matching\n\nSpecimens that did not match to a record in WDRS need to be matched on demographics in a separate fuzzy matching process\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Send records to fuzzy matching that did not match to a record in WDRS or which have duplicate SCA but different CASE ID\n# All records sent to fuzzy matching should have demographic info\nfuzzy_matching_input <- filter(phl_quality, !is.na(QA_CASE_ID) | !is.na(QA_SCA_INT_DUPE),\n                         !is.na(FIRST_NAME),\n                         FIRST_NAME != \"\",\n                         !is.na(LAST_NAME),\n                         LAST_NAME != \"\",\n                         !is.na(DOB),\n                         DOB != \"\")\n\n# Format data for submission to fuzzing matching\nfuzzy_matching_input <- fuzzy_matching_input %>%\n  mutate(MIDDLE_NAME = NA,\n         ALTERNATIVE_ID = NA) %>%\n  select(SEQUENCE_REASON,\n         GISAID_ID = SEQUENCE_ACCESSION,\n         PANGO_LINEAGE = SEQUENCE_VARIANT_OPEN_TEXT,\n         FIRST_NAME,\n         LAST_NAME ,\n         MIDDLE_NAME,\n         SUBMITTING_LAB = SEQUENCE_LAB,\n         DOB,\n         SPECIMEN_COLLECTION_DATE = SEQUENCE_SPECIMEN_COLLECTION_DATE,\n         CASE_ID,\n         SEQUENCE_STATUS,\n         ALTERNATIVE_ID,\n         LAB_ACCESSION_ID = SEQUENCE_CLINICAL_ACCESSION,\n         ID)\n                         \n\n# remove records sent to fuzzy matching from the records sent to the roster or for review\nphl_quality <- filter(phl_quality, !ID %in% fuzzy_matching_input$ID) %>% \n  # remove demographic info\n  select(-FIRST_NAME, -LAST_NAME, -DOB)\n\n\n\nif(nrow(fuzzy_matching_input) > 0){\n  # keep track of records written\n  new_records <- c(new_records, fuzzy_matching_input$ID)\n  \n  fuzzy_matching_input <- fuzzy_matching_input %>% select(-ID)\n  # write records to fuzzy matching input folder\n  fuzzy_matching_filepath <- file.path(\"Submissions/Fuzzy_Match\", paste0(\"PHL_FUZZY_MATCHING\", today(), \".csv\"))\n  write_csv(fuzzy_matching_input, fuzzy_matching_filepath)\n}\n```\n:::\n\n\n\n\n\n\n# Keep_na {.tabset}\n\n## Filter Records for Keep NA\n\nThese rows were missing important data and need to be sent to the keep_na file so that we can attempt to match them later.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# add to keep na records that are missing case or sequence accession or sequence clinical accession, but where the status is not pending and the sequence clinical accession is not in wdrs\nkeep_na <- filter(phl_quality, (!is.na(QA_CASE_ID) |\n                                  !is.na(QA_SCA_NA) |\n                                  !is.na(QA_SEQ_STAT)) &\n                    SEQUENCE_STATUS != \"PENDING\" &\n                    is.na(QA_SCA_WDRS_DUPE))\n\n# remove records sent to keep_na from the records sent elsewhere\nphl_quality <- filter(phl_quality, !ID %in% keep_na$ID)\n\n\n# Read in current keep na list\nkeep_na_running <- read_csv(\"keep_na/keep_na.csv\",\n                   col_types = cols(.default = \"c\"),\n                   na = c(\"\", \"NA\", \"N/A\")) \n\n# Filter out records already in keep na\n# and select the relevant columns\nkeep_na_final <- filter(keep_na, !SEQUENCE_CLINICAL_ACCESSION %in% keep_na_running$SEQUENCE_CLINICAL_ACCESSION) %>%\n  select(CASE_ID:Case.Note) %>%\n  mutate(DATE_PROCESSED = as.character(today()))\n\nif(nrow(keep_na_final > 0)) {\n  # keep track of records written\n  new_records <- c(new_records, keep_na_final$ID)\n  keep_na_final <- keep_na_final %>% select(-ID)\n  \n    keep_na_final %>%\n      write_csv(\"keep_na/keep_na.csv\", na = \"\", append = TRUE)\n  }  \n```\n:::\n\n\n\n\n\n\n## Check keep_na File\n\nEnsures that records are appended to the keep_na file. If the number of records that should have appended to the keep_na file does not match then it outputs the keep_na_final as a separate file so data is not lost\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# if keep_na_final > 0 \nif(nrow(keep_na_final) > 0) {\n# bring in the updated keep_na \nkeep_na_running_update <- read_csv(\"keep_na/keep_na.csv\",\n                   col_types = cols(.default = \"c\"),\n                   na = c(\"\", \"NA\", \"N/A\")) \n\n}  \n\n# if the difference in the nrow between the keep_na originally brought in and the keep_na updated with keep_na_final does not equal the nrow of keep_na_final\n\nif(nrow(keep_na_final) > 0) {\n  if ((!((nrow(\n    keep_na_running_update\n  )) - (nrow(keep_na_running))) == nrow(keep_na_final))) {\n    # output keep_na_final as a separate file into a holding folder (to ensure this is added to keep_na later on)\n    keep_na_final %>%\n      write_csv(file.path(\"keep_na/Add_Holding\",\n                paste0(\"PHL_\",format(now(), \"%Y-%m-%d-%H%M%S\"), \".csv\")), na = \"\")\n    \n  }\n}\n```\n:::\n\n\n\n\n\n\n\n# PHL Final Roster\n\nApply all of the filters and print the rows that make it through these quality checks to the write_roster_here folder.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# filter out records that fail any quality check\nphl_roster_final <- filter(phl_quality, sum==0) %>% select(CASE_ID:Case.Note)\n\nif(nrow(phl_roster_final > 0)) {\n  # keep track of records written\n  new_records <- c(new_records, phl_roster_final$ID)\n  phl_roster_final <- phl_roster_final %>% select(-ID)\n  \n  roster_filepath <- file.path(\"write_roster_here\", paste0(\"phl_NewSeq_\", format(now(), \"%Y-%m-%d-%H%M%S\"), \".csv\"))\n  write_csv(phl_roster_final, roster_filepath, na = \"\")\n    \n}\n```\n:::\n\n\n\n\n\n\n\n# For review records\n\nSelect records that failed various filters and write to the For_Review folder for manual review\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nphl_for_review <- filter(phl_quality, sum > 0)\n\nif(nrow(phl_for_review)) {\n  new_records <- c(new_records, phl_for_review$ID)\n   \n  phl_for_review <- phl_for_review %>%\n    select(-ID, -sum)\n  \n  for_review_filepath <- file.path(\"For_Review/to_process\", paste0(\"PHL_review_\", today(), \".csv\"))\n    # write to csv\n  write_csv(phl_for_review, for_review_filepath, na = \"\")\n}\n```\n:::\n\n\n\n\n\n\n# Processed Record List\n\nAdd to list of records that have been processed by the script\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nif(length(new_records) > 0) {\n  # add records processed during this run to the list\n  new_records <- as.data.frame(new_records) %>% magrittr::set_colnames(\"SEQUENCE_ACCESSION\")\n  new_records$date_processed <- today()\n  \n  write_csv(new_records, \"Completed_Submissions/PHL_Records/phl_processed_records.csv\", na = \"\", append = TRUE)\n  \n}\n```\n:::\n\n\n\n\n\n\n# Save outputs for Seq 2.0 comparison\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nkeep_na_final$output_location <- \"keep_na\"\nphl_for_review$output_location <- \"for_review\"\nfuzzy_matching_input$output_location <- \"fuzzy\"\nphl_roster_final$output_location <- \"WDRS\"\n\nall <- bind_rows(keep_na_final,\n          phl_for_review,\n          fuzzy_matching_input,\n          phl_roster_final)\n\nwrite_csv(all,\n          paste0(\"2.0_dev_env/seq_1.0_outputs/\",Sys.Date(),\"_phl_outputs.csv\"))\n```\n:::\n\n\n\n\n\n\n\n# File cleanup\n\nMove files from Submissions folder to Completed_Submissions and rename as complete\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# PHL primary dashboard\nnew_file_path <-\n  file.path(\"Completed_Submissions/PHL\",\n  paste0(\"complete_\", today(), \".xlsx\"))\nfile_move(phl_filename,\n          new_file_path)\n\n# RedCap\nnew_file_path2 <-\n  file.path(\"Completed_Submissions/REDCap_Source_Viewer\",\n  paste0(\"complete_\", today(), \".xlsx\"))\nfile_move(redcap_filename,\n          new_file_path2)\n\n# Sentinel Surveillance\nnew_file_path3 <-\n  file.path(\"Completed_Submissions/Surveillance_Source_Viewer\",\n  paste0(\"complete_\", today(), \".xlsx\"))\nfile_move(surveillance_filename,\n          new_file_path3)\n\n# Epi (All Specimens)\nnew_file_path4 <-\n  file.path(\"Completed_Submissions/PHL\",\n  paste0(\"epi_complete_\", today(), \".xlsx\"))\nfile_move(epi_filename,\n          new_file_path4)\n```\n:::\n\n\n\n\n\n\n# Completed Email {.tabset}\n\n## Write Email\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# initialize empty message\nPHL_message <- \"\"\n\n# Write separate messages if PHL records were added to write roster or not\nif(nrow(phl_roster_final) > 0) {\n  valid_files_message <-  paste0(\"There were a total of \", nrow(phl_roster_final), \" record(s) from PHL that are ready to be rostered. A table of these records was added to the write_roster_here folder.\")\n} else {\n  valid_files_message <- paste0(\"There were no new valid records from PHL that are ready to be rostered. No new table was added to the write_roster_here folder.\")\n}\n\n\nPHL_message <- paste0(PHL_message, valid_files_message)\n\n# initialize empty sting for files written to For_Review\ninvalid_files <- \"\"\n\n# if there were records requiring review, append it to the message\nif (nrow(phl_for_review) > 0) {\n  invalid_files <- paste0(invalid_files,\"\\n\\n\" , \"There were a total of \", nrow(phl_for_review), \" record(s) processed that contained an error. A table of these records was added to the For_Review/to_process folder.\")\n}\n\n\n# write different messages depending on whether files were written to the For_Review folders or not\nif(nchar(invalid_files) > 0) {\n  PHL_message <- paste0(PHL_message, \"\\n\\nA subset of records that were processed require manual review: \", invalid_files)\n} else {\n  PHL_message <- paste0(PHL_message, \"\\n\\nNo PHL records were added to the For_Review folders for manual review.\")\n}\n\n\n# if there were records that required fuzzy matching, append it to the message\nif (nrow(fuzzy_matching_input) > 0) {\n  fuzzy_match_filepath <- file.path(\"Submissions/Fuzzy_Match\", paste0(\"PHL_FUZZY_MATCHING\", today(), \".csv\"))\n  PHL_message <- paste0(PHL_message, \"\\n\\n\", \"There are \", nrow(fuzzy_matching_input), \" records that require fuzzy matching. These records do not match to an event in WDRS by an accession ID but do contain demographic information that can be used to match. These records can be found at: \", \"\\n\", fuzzy_match_filepath)\n} else {\n  PHL_message <- paste0(PHL_message, \"\\n\\n\", \"There were no records from PHL for fuzzy matching.\")\n}\n\n# if there were records added to keep na, append it to the message\nif (nrow(keep_na_final) > 0) {\n  PHL_message <- paste0(PHL_message, \"\\n\\n\", \"There are \", nrow(keep_na_final), \" records that were added to the keep na file.\")\n}\n\n\n# Finalize message\nPHL_message <- paste0(PHL_message, \"\\n\\n\", \"Note: This is an automated message. Please enable your outlook to include extra line breaks to view this message in its proper format.\", \"\\n\\n\", \"This message is in development, and will be updated. If you see any errors reach out to DIQA. Thanks!\")\n```\n:::\n\n\n\n\n\n\n## Send Email\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# assign email components to vectors\nemail_from <- \"\"\nemail_to <- \"\"\nemail_subject <- paste0(\"SEQUENCING - PHL Dashboard Run Summary Automated Email\", month(today()), \"/\", day(today()))\nemail_body <- paste0(\"The PHL Submission(s) have been processed for \", today(), \". \", \"See below for a summary.\\n\\n\", PHL_message)\n\n# send it only if running in production mode, where data is read from and written to the Y drive\n\nsendmailR::sendmail(from = email_from,\n                    to = email_to,\n                    subject = email_subject,\n                    msg = email_body,\n                    headers= list(\"Reply-To\" = email_from),\n                    control = list(smtpServer = \"\")\n                    )\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}