{
  "hash": "e323a50f7d2953f025a14fe53d2e0763",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"WDRS Logic Checks\"\nauthor: \"Frank Aragona\"\ndate: \"2024-03-18\"\nparams: \n  test_mode: FALSE\n---\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nknitr::opts_chunk$set(eval = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.css .cell-code .hidden}\n# .myCode {\n# background-color: black;\n# }\n# .Rchunk {\n#   height: 100%;\n#   overflow: auto;\n#   background-color: black;\n# }\n# \n# .Rout {\n#   height: 100%;\n#   overflow: auto;\n#   background-color: lightblue !important;\n#   font-weight: bolder;\n# }\n```\n:::\n\n::: {.cell .hidden}\n\n```{.r .cell-code .hidden}\nsource_rmd <- function(file, local = FALSE, ...){\n  options(knitr.duplicate.label = 'allow')\n  tempR <- tempfile(tmpdir = \".\", fileext = \".R\")\n  on.exit(unlink(tempR))\n  knitr::purl(file, output=tempR, quiet = TRUE)\n  envir <- globalenv()\n  source(tempR, local = envir, ...)\n}\nlibrary(DBI)\nlibrary(odbc)\nlibrary(lubridate)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(here)\nlibrary(fs)\nlibrary(data.table)\n# options(\"install.lock\"=FALSE)\n#library(splitstackshape)\nlibrary(gt)\nlibrary(viridis)\nlibrary(kableExtra)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(janitor)\nlibrary(kableExtra)\nlibrary(gtExtras)\nlibrary(blastula)\nlibrary(keyring)\nlibrary(curl)\n```\n:::\n\n\n\n\n\n# Introduction\nThe purpose of this script is to QA data that has been rostered into WDRS. There are conditional flags that will check for specific errors in the sequencing data and a list of records will be output in the end.\n# Step 1: Code Setup\n## Pull in Tables and Functions\nThis pulls in the following:\n*   Connection List data object\n*   WDRS Flattened table\n*   WDRS Entire Table\n*   WDRS Flattened Table Check for last time the table was refreshed\n*   Creates standards for lab names, SEQ_REASON, and pulls in `lineages.csv`\n*   GISAID metadata and WA GISAID tables\n*   Creates the paste5 function\n**There are functions that will also tell us if data hit the character limit and the last time WDRS Flattened Table was refreshed**\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsource(file.path(\"C:/Users/\", Sys.getenv(\"USERNAME\"), \"Projects/Sequencing/QA/WDRS_Logic_Checks_QA_Functions.R\"), local = knitr::knit_global())\n```\n:::\n\n\n\n\n\n# Step 2: Conditional Statements/Logic Checks\nCreate individual if_else statements that will check certain errors in the data. For a dictionary of flags, see [Flag Dictionary](#dictionary) at the end of this document.\n## Code for each logic check. These are individual checks \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlogic_checks <- wdrs_flat_sep_rows2 %>%\n    mutate(\n## ---- reason-null\n      # 2/15/2022 FA - As we discussed, add !is.na(SEQUENCE_LAB) to the reason-null check because some records with missing data for all columns were getting flagged as reason_null but they have other issues. We want to use this check to determine aprox. when (month/year) when a record was missing a reason. So records before July were not regularly filling out the reason so those are less of a concern, but we want to flag all because molecular is trying to fill all of them in roster updates. \n        reason_null_warn = if_else(\n            SEQUENCE_SPECIMEN == \"Yes\" & is.na(SEQUENCE_REASON) & !is.na(SEQUENCE_LAB),\n            print(\"Warning: SEQUENCE_REASON is NULL\"),\n            NULL\n        ),\n## ---- stop\n## ---- reason-warn\n        reason_warn = if_else(\n            SEQUENCE_SPECIMEN == \"Yes\" & !SEQUENCE_REASON %in% reasons,\n            print(\"Warning: SEQUENCE_REASON not standardized\"),\n            NULL\n        ),\n## ---- stop\n## ---- var-status-warn\n        var_status_warn = if_else(\n            (!is.na(SEQUENCE_VARIANT_OPEN_TEXT) & SEQUENCE_VARIANT_OPEN_TEXT != \"Unassigned\") & str_detect(toupper(SEQUENCE_STATUS),\"COMPLETE\",negate = T),\n            print(\n                \"Warning: SEQUENCE_VARIANT_OPEN_TEXT filled but SEQUENCE_STATUS is not COMPLETE\"\n            ),\n            NULL\n        ),\n## ---- stop\n## ---- labs-check-warn\n        SA_null_status_complete_warn = if_else(\n            is.na(SEQUENCE_ACCESSION)& !(toupper(SEQUENCE_STATUS) %in% c(\"FAILED\", \"LOW QUALITY\", \"FAILED, LOW QUALITY\", NA)),\n            print(\n                \"Warning: SEQUENCE_ACCESSION number NULL but status not FAILED/LOW QUALITY\"\n            ),\n            NULL\n        ),\n## ---- stop\n## ---- SA-null-variant-exists-warn\n        # NW Genomics is spelled wrong, need to include partial strings\n        # IF failed or low quality and lab not in PHL or NW Genomics then mark\n        SA_null_variant_exists_warn = if_else(\n            is.na(SEQUENCE_ACCESSION)&\n            SEQUENCE_SPECIMEN==\"Yes\"& \n            !is.na(SEQUENCE_VARIANT_OPEN_TEXT)\n            &(!SEQUENCE_ACCESSION %in% wa_gisaid$SEQUENCE_ACCESSION),\n            print(\"Warning: SEQUENCE_VARIANT_OPEN_TEXT exists but SEQUENCE_ACCESION number is null\"),\n            NULL\n        ),\n## ---- stop\n## ---- variant-check-warn\n        variant_check_warn = if_else(\n            !(SEQUENCE_VARIANT_OPEN_TEXT %in% variants) & SEQUENCE_VARIANT_OPEN_TEXT != \"Unassigned\", print(\"Warning: SEQUENCE_VARIANT not of concern/interest - check or update list\"),\n            NULL\n        ),\n## ---- stop\n## ---- lab-name-warn\n        lab_name_warn = if_else(SEQUENCE_SPECIMEN == \"Yes\" &\n            (!SEQUENCE_LAB %in% lab_names), print(\"Warning: SEQUENCE_LAB not standardized - check or update list\"),\n            NULL\n        ),\n## ---- stop\n## ---- date-warn\n        date_warn = if_else(\n            SEQUENCE_SPECIMEN_COLLECTION_DATE < \"2020-01-05\" | SEQUENCE_SPECIMEN_COLLECTION_DATE > today(),\n            print(\"Warning: SEQUENCE_SPECIMEN_COLLECTION_DATE out of range. Before 1/19/2020 or after today's date\"),\n            print(\"Warning: SEQUENCE_SPECIMEN_COLLECTION_DATE out of range. Before 1/05/2020 or after today's date\"),\n            NULL\n        ),\n## ---- stop\n## ---- seq-lab-neg-warn\n        seq_lab_neg_warn = if_else(SEQUENCE_SPECIMEN == \"No\" &\n            (!is.na(SEQUENCE_ACCESSION) |\n              !is.na(SEQUENCE_VARIANT_OPEN_TEXT)), \n            print(\"Warning: SEQUENCE_SPECIMEN = 'No' but sequencing data attatched\"),\n            NULL\n        ),\n## ---- stop\n## ---- SCA-SA-null-warn\n        SCA_SA_null_warn = if_else(\n            (is.na(SEQUENCE_ACCESSION) & is.na(SEQUENCE_CLINICAL_ACCESSION)) & SEQUENCE_SPECIMEN == \"Yes\" &\n              (!str_detect(toupper(SEQUENCE_STATUS),\"FAILED|LOW QUALITY\") | is.na(SEQUENCE_STATUS)),\n            print(\n                \"Warning: SEQUENCE_ACCESSION number and SEQUENCE_CLINICAL_ACCESSION numbers missing\"\n            ),\n            NULL\n        ),\n## ---- stop\n## ---- unexpected-char-warn\n        #11/22/2021 Flag values that aren't expected in a given column - ex. Notes shouldn't be in accession columns\n        unexpected_char_warn = if_else(\n            (str_count(SEQUENCE_CLINICAL_ACCESSION, \" \") & !str_detect(SEQUENCE_CLINICAL_ACCESSION, \"TSC|SPC|FH|MOLE|ACOV|KCMEO|PCME\")) |\n              str_count(SEQUENCE_ACCESSION, \" \") > 1 |\n              str_count(SEQUENCE_SPECIMEN, \" \") > 1 |\n              str_count(CASE_ID, \" \") > 1 | \n              str_count(SEQUENCE_REASON, \" \") > 3 |\n              str_count(SEQUENCE_DATE, \" \") > 1 |\n              str_count(SEQUENCE_STATUS, \" \") > 1 |\n              str_count(SEQUENCE_VARIANT_OPEN_TEXT, \" \") > 1,\n            print(\n                \"Warning: Unexpected characters in a column\"\n            ),\n            NULL\n        ),\n## ---- stop\n## ---- gisaid-flag-warn\n        # gisaid_flag_warn = if_else(!is.na(SEQUENCE_ACCESSION) & \n        #                  (!SEQUENCE_ACCESSION %in% wa_gisaid$virus_name_clean), \n        #                         print(\"Warning: SEQUENCE_ACCESSION not found in GISAID\"),\n        #                         NULL\n        # ),\n## ---- stop\n        \n    )\n```\n:::\n\n\n\n\n\n## Flag if SA not in GISAID\nPull in the separate unmatched to gisaid script as it is a separate process to flag these data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsource_rmd(paste0(here(),\"/QA/Unmatched_GISAID_ID.Rmd\"))\nGISAID_flag<- GISAID_flag %>%\n  select(CASE_ID,SEQUENCE_ACCESSION=SEQUENCE_ACCESSION_WDRS,gisaid_flag_warn)\n# append to logic_checks\nlogic_checks <- logic_checks %>%\n  full_join(GISAID_flag,by= c(\"CASE_ID\",\"SEQUENCE_ACCESSION\"))\n```\n:::\n\n\n\n\n\n# Step 3: Combine each warning into one column\nSince one row/event can have more that one flag, we need to paste the flags together to be able to show all flags in one row. This also allows us to put all flags in one column to make the data easier to query.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nprefinal <- logic_checks %>%\n  unite(\"flag\",dplyr::ends_with('_warn'),na.rm=TRUE,remove=FALSE)\n```\n:::\n\n\n\n\n\n## Creating a break down of what warnings were found\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsummary <- prefinal %>%\n  group_by(flag) %>%\n  summarise(n = n())\nsummary\n```\n:::\n\n\n\n\n\n# Step 4: Checks for Duplicates\nThis uses Marcela's code to check for different types of duplicates\n1.    Duplicates where the `SEQUENCE_ACCESSION_NUMBER` and the `SEQUENCE_CLINICAL_ACCESSION_NUMBER` and the `SEQUENCE_VARIANT_OPEN_TEXT` are repeated\n2.    Duplicates where the `SEQUENCE_CLINICAL_ACCESSION_NUMBER` is duplicate but different `SEQUENCE_ACCESSION_NUMBER`\n3.    Duplicates where the `SEQUENCE_ACCESSION_NUMBER` is duplicated, the `SEQUENCE_LAB` is duplicated, but different `SEQUENCE_CLINICAL_ACCESSION_NUMBER`\n4.    `CASE_ID`s sequenced by different labs - this does not actually get flagged, it was just for Marcela to check\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Filtering out NAs\nFiltered_WDRSSeq <- wdrs_flat %>%\n  filter((!is.na(\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER\n  )) & (!is.na(\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER\n  )))\nLongFormat_WDRSSeq <- Filtered_WDRSSeq %>%\n  separate_rows(\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT,\n    CDC_N_COV_2019_SEQUENCE_LAB,\n    sep = \", \"\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Trimming trailing spaces\nLongFNoSpace_WDRSSeq <- LongFormat_WDRSSeq %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER = trimws(\n      LongFormat_WDRSSeq$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER\n    )\n  ) %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER = trimws(\n      LongFormat_WDRSSeq$CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER\n    )\n  ) %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT = trimws(LongFormat_WDRSSeq$CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT)\n  ) %>%\n  mutate(CDC_N_COV_2019_SEQUENCE_LAB = trimws(LongFormat_WDRSSeq$CDC_N_COV_2019_SEQUENCE_LAB))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Filtering out NA and empties\nClean_WDRSSeq <- LongFNoSpace_WDRSSeq %>%\n  filter(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER != \"\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Duplicates where the SEQUENCE_ACCESSION_NUMBER and the SEQUENCE_CLINICAL_ACCESSION_NUMBER and the SEQUENCE_VARIANT_OPEN_TEXT are repeated\nFindingDuplicates <- Clean_WDRSSeq %>%\n  group_by(\n    CASE_ID,\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT\n  ) %>%\n  summarize(n = n())\nDuplicates <- FindingDuplicates %>%\n  filter(n > 1) %>%\n  mutate(flag = \"Warning: Duplicate - SEQUENCE_ACCESSION and SEQUENCE_CLINICAL_ACCESSION numbers and variant repeated\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Duplicates where the SEQUENCE_CLINICAL_ACCESSION_NUMBER is duplicate but different SEQUENCE_ACCESSION_NUMBER\nclin_group <- Clean_WDRSSeq %>%\n  group_by(\n    CASE_ID,\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER\n  ) %>%\n  summarize(n = n()) %>%\n  filter(n > 1)\nclin_group2 <- anti_join(clin_group, Duplicates, by = \"CASE_ID\")\nclin_accession_dup <-\n  merge(clin_group2, wdrs_flat_sep_rows2, by = \"CASE_ID\") %>%\n  filter(!CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT == \", \")\nclin_accession_dup2 <- clin_accession_dup %>%\n  mutate(flag = if_else(\n    !str_detect(\n      clin_accession_dup$CDC_N_COV_2019_SEQUENCE_LAB,\n      paste(c(\"PHL, CDC\", \"CDC, PHL\", \"PHL\"), collapse = '|')\n    ),\n    print(\n      \"Warning: Duplicate - SEQUENCE_CLINICAL_ACCESSION dupicated but different SEQUENCE_ACCESSION number\"\n    ),\n    NULL\n  ))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Duplicates where the SEQUENCE_ACCESSION_NUMBER is duplicated, the SEQUENCE_LAB is duplicated, but different SEQUENCE_CLINICAL_ACCESSION_NUMBER\nseq_group <- Clean_WDRSSeq %>%\n  group_by(CASE_ID,\n           CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n           CDC_N_COV_2019_SEQUENCE_LAB) %>%\n  summarize(n = n()) %>%\n  filter(n > 1)\nseq_group2 <- anti_join(seq_group, Duplicates, by = \"CASE_ID\")\nseq_accession_dup <-\n  merge(seq_group2, wdrs_flat_sep_rows2, by = \"CASE_ID\") %>%\n  filter(!CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT == \", \") %>%\n  mutate(flag = \"Warning: Duplicate - SEQUENCE_ACCESSION duplicated but different SEQUENCE_CLINICAL_ACCESSION number\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### CASE_IDs sequenced by different labs\ncase_id_group <- Clean_WDRSSeq %>%\n  group_by(CASE_ID) %>%\n  summarize(n = n()) %>%\n  filter(n > 1)\ncase_id_group2 <- Clean_WDRSSeq %>%\n  group_by(CASE_ID, CDC_N_COV_2019_SEQUENCE_LAB) %>%\n  summarize(n = n()) %>%\n  filter(n > 1)\ncase_id_group3 <- anti_join(case_id_group, case_id_group2, by = \"CASE_ID\")\ncase_id_dup <- merge(case_id_group3, Clean_WDRSSeq, by = \"CASE_ID\") %>%\n  filter(!CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT == \"\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nLongFormat_WDRSSeq2 <- Filtered_WDRSSeq %>%\n  separate_rows(\n    CDC_N_COV_2019_SEQUENCE_SPECIMEN,\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT,\n    CDC_N_COV_2019_SEQUENCE_LAB,\n    sep = \", \"\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Find duplicate failed/low quality obs with missing clinical accession numbers\nLongFNoSpace_WDRSSeq2 <- LongFormat_WDRSSeq2 %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_SPECIMEN = trimws(LongFormat_WDRSSeq2$CDC_N_COV_2019_SEQUENCE_SPECIMEN)\n  ) %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER = trimws(\n      LongFormat_WDRSSeq2$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER\n    )\n  ) %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER = trimws(\n      LongFormat_WDRSSeq2$CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER\n    )\n  ) %>%\n  mutate(\n    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT = trimws(LongFormat_WDRSSeq2$CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT)\n  ) %>%\n  mutate(CDC_N_COV_2019_SEQUENCE_LAB = trimws(LongFormat_WDRSSeq2$CDC_N_COV_2019_SEQUENCE_LAB))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Filtering out NA and empties\nClean_WDRSSeq2 <- LongFNoSpace_WDRSSeq2 %>%\n  filter(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER != \"\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n### Duplicates where the SEQUENCE_ACCESSION_NUMBER and the SEQUENCE_CLINICAL_ACCESSION_NUMBER and the SEQUENCE_VARIANT_OPEN_TEXT are repeated\nFindingDuplicates2 <- Clean_WDRSSeq2 %>%\n  group_by(\n    CASE_ID,\n    CDC_N_COV_2019_SEQUENCE_SPECIMEN,\n    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n    CDC_N_COV_2019_SEQUENCE_STATUS\n  ) %>%\n  summarize(n = n())\nDuplicates2 <- FindingDuplicates2 %>%\n  filter(n > 1) %>%\n  mutate(flag = \"Warning: Duplicate - SEQUENCE_ACCESSION and SEQUENCE_CLINICAL_ACCESSION numbers and variant repeated\")\n```\n:::\n\n\n\n\n\n# Step 5: Create Final Dataset\nAppend the conditional flags with the duplicates to create one dataset\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfinal <-\n  bind_rows(prefinal, clin_accession_dup2, Duplicates, seq_accession_dup) %>%\n  filter(str_detect(flag, \"Warning\")) %>%\n  # select(-c(starts_with(\"SEQUENCE\"), n, contains(\".x\"), contains(\".y\"))) %>%\n  mutate(failedflag = if_else((\n    toupper(CDC_N_COV_2019_SEQUENCE_STATUS) == \"FAILED\" &\n      is.na(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)), 1, 0)) %>%\n  filter((STATUS != 6 |\n            is.na(STATUS)) & \n           (failedflag != 1 | \n              is.na(failedflag))) %>%\n  filter(ACCOUNTABLE_COUNTY != \"WA-99\")%>%\n  # mutate( yearsub = if_else(is.na(SEQUENCE_SPECIMEN_COLLECTION_DATE),format(CREATE_DATE, \"%Y\"),format(SEQUENCE_SPECIMEN_COLLECTION_DATE,\"%Y\")))%>%\n  mutate(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE = as.Date(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE,\"%m/%d/%Y\"))%>%\n  mutate(date = if_else(\n    is.na(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE),\n    as.Date(CREATE_DATE),\n    as.Date(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE)))%>%\n  mutate(month = format(date, \"%m\"), year = format(date, \"%Y\")) %>%\n  select(-dplyr::ends_with('.x'))%>%\n  select(-dplyr::ends_with('.y'))\n```\n:::\n\n\n\n\n\nSummary of final flags\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfinal_summary <- final %>%\n  group_by(flag) %>%\n  summarise(n = n())\nfinal_summary\n```\n:::\n\n\n\n\n\n# Step 6: Special Requests\n## Output a list of obs that have status = 6 and FAILED/Low QUALITY\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Update a list of all deleted excluding FAILEd\nDeletedCases<- prefinal %>%\n  mutate(failedflag = if_else((\n    toupper(CDC_N_COV_2019_SEQUENCE_STATUS) %in% c(\"COMPLETE\", \"LOW QUALITY\") &\n      is.na(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)), 1, 0)) %>%\n  filter((STATUS == 6 |\n            is.na(STATUS)) & (failedflag == 1 | is.na(failedflag)))\n \nif(nrow(DeletedCases)!=0){\n  DeletedCases %>%\n   fwrite(\n    paste0(\"\",\n           today(),\n           \".csv\"\n           )\n   )\n  print(\"Send this list to end users that these observations have status=6 and are COMPLETE or LOW QUALITY\")\n} else{\n  print(\"No DeletedCases, skip me!\")\n}\n```\n:::\n\n\n\n\n\n## Try to match missing clinical and accession numbers to existing rosters compiled\nIf any records are missing SA and SCA, connect to compiled rosters and see if they're there. Go into COMPILEDROSTERS_WDRS and pull code that compiles all existing rosters\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nmiss <- final %>%\n  filter(\n    str_detect(\n      flag,\n      \"Warning: SEQUENCE_ACCESSION number and SEQUENCE_CLINICAL_ACCESSION numbers missing\"\n    )\n  )\nif(nrow(miss)!=0){\nlist_rosters <-\n  dir_ls(\n    path = \"\",\n    recurse = TRUE,\n    type = \"file\",\n    regexp = \"Compiled_Roster.*csv\"\n  )\n# Get all rosters\ncompiled_roster_df <- list_rosters %>%\n  map_if(str_sub(.,-4,-1) == \".csv\",\n         function(x)\n           read_csv(\n             x,\n             col_types = cols(.default = \"c\"),\n             na = c(\"\", \"NA\", \"N/A\")\n           )\n         )\ncompiled_roster_df_bind <-\n  bind_rows(compiled_roster_df, .id = \"column_label\")\n# arranges vars in the correct order\n#are there any people that used to be active to a status = 6. Has to be recurrent\ncompiled_roster_df_clean <- compiled_roster_df_bind %>%\n  select(\n    c(\n      column_label,\n      CASE_ID,\n      SEQUENCE_SGTF,\n      SEQUENCE_SPECIMEN,\n      SEQUENCE_REASON,\n      SEQUENCE_DATE,\n      SEQUENCE_LAB,\n      SEQUENCE_STATUS,\n      SEQUENCE_REPOSITORY,\n      SEQUENCE_ACCESSION,\n      SEQUENCE_VARIANT_OPEN_TEXT,\n      SEQUENCE_CLINICAL_ACCESSION,\n      SEQUENCE_SPECIMEN_COLLECTION_DATE,\n      SEQUENCE_NOTES,\n      SEQUENCE_REVIEWED,\n      Case.Note\n    )\n  )\ncompiled_roster_df_clean\nmatch <- inner_join(miss, compiled_roster_df_clean, by = \"CASE_ID\")\nunmatch <- anti_join(miss, match, by = \"CASE_ID\")\n}\n```\n:::\n\n\n\n\n\n### Output records that matched or didn't match to existing compiled rosters in WDRS\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nif(!is.null(nrow(match))){\nmatch %>%\n  fwrite(paste0(\"\", today(), \".csv\"))\n  paste0(nrow(match),\" records with missing SA and SCA were matched to previous rosters. Send to end users!\")\n} else{\n  print(\"No matches here, on to the next\")\n}\nif(exists(\"unmatch\") && nrow(unmatch)!=0){\nunmatch %>%\n  fwrite(paste0(\"\", today(),\".csv\"))\n  print(\"missingSEQ_and_Clin - This is a list of observations with missing SEQUENCE_ACCESSION and SEQUENCE_CLINICAL_ACCESSION\")\n} else{\n  print(\"No records with missing SA and SCA\")\n}\n```\n:::\n\n\n\n\n\n## Create list of closed cases that Data Support needs to open in order to fix\nThis was specific for opening closed cases for non standard `SEQUENCE_REASON` but can be adjusted for other purposes\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# final %>%\n#   filter(str_detect(flag,\"SEQUENCE_REASON not standardized\"))%>%\n#   fwrite(paste0(project_folder,\"/WDRS QA\",\"/\",\"Closed_Cases\",today(),\".csv\"))\n```\n:::\n\n\n\n\n\n# Step 7: Create Outputs For End Users\n## Prep the summary table\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Get the CREATE_DATE from wdrs_flat\nsum_table_raw<- final %>%\n  select(CASE_ID,year,dplyr::ends_with('_warn')) %>%\n  gather(key, value, ends_with('_warn'), na.rm = TRUE)%>%\n  count(value,year) %>% \n  pivot_wider(names_from = year,values_from = n) %>%\n  replace(is.na(.), 0) %>%\n  rowwise()%>%\n  mutate(Total = sum(c_across(where(is.numeric))))%>%\n  mutate(value = str_remove(value,\"Warning: \"))%>%\n  arrange(desc(Total))\n# Pull in the previous table for comparisons\nlast_table_file <- dir_ls(\n  path = file.path(project_folder,\"WDRS QA/Logic Checks\"),\n  recurse = TRUE,\n  type = \"file\",\n  regexp = \"summary_table.*csv\"\n)\nlast_table <- read_csv(last_table_file[which.max(file.mtime(last_table_file))])\nsum_table_clean <- full_join(sum_table_raw,last_table,by = \"value\") %>%\n  replace(is.na(.), 0) %>%\n  mutate(Change = Total.x - Total.y) %>%\n  select(-(contains(\".y\")))\ncolnames(sum_table_clean)<-gsub(\".x\",\"\",colnames(sum_table_clean))\n```\n:::\n\n\n\n\n\n## Create Summary Table\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nsum_table<- gt(sum_table_clean) %>%\n  cols_label(value = \"Error Type\") %>%\n  tab_header(title = md(\"Summary of COVID-19 Sequence Data Errors in WDRS\")) %>% \n  gtExtras::gt_fa_rank_change(Change, font_color = \"match\",fa_type = \"level\") %>%\n  tab_footnote(\n    footnote = \"Change in error counts compared to previous QA check outputs\",\n    location = cells_column_labels(\"Change\")) %>%\n  #Add a data source footnote\n  tab_source_note(source_note = \"*Year is derived from SPECIMEN_COLLECTION_DATE. If missing, CREATE_DATE is used\")%>%\n  data_color(columns= Total,\n             colors=scales::col_numeric(\n               palette = c(\"#FFFFFF\",viridis(350,alpha=1,begin=0,end=1,direction=-1)),domain=NULL ))%>%\n  #All column headers are capitalised\n  opt_all_caps() %>% \n  #Use the Chivo font\n  #Note the great 'google_font' function in 'gt' that removes the need to pre-load fonts\n  opt_table_font(\n    font = list(\n      google_font(\"Chivo\"),\n      default_fonts()\n    )\n  ) %>%\n  tab_options(\n    #Remove border between column headers and title\n    column_labels.border.top.width = px(3),\n    column_labels.border.top.color = \"black\",\n    #Remove border around table\n    table.border.top.color = \"black\",\n    table.border.bottom.color = \"black\",\n    #Reduce the height of rows\n    data_row.padding = px(3),\n    #Adjust font sizes and alignment\n    source_notes.font.size = 12,\n    heading.align = \"left\"\n  )%>%\n   tab_style(\n    style = list(\n      cell_borders(\n        sides = \"left\",\n        color = \"black\",\n        weight = px(3)\n      )\n    ),\n    locations = list(\n      cells_body(\n        columns = c('2020','Change')\n      )\n    )\n  )%>%\n  # We use tab_style() to change style of cells\n  # cell_borders() provides the formatting\n  # locations tells it where\n  # Add black borders to the bottom of all the column labels\n  tab_style(\n    style = list(\n      cell_borders(\n        sides = \"bottom\",\n        color = \"black\",\n        weight = px(3)\n      )\n    ),\n    locations = list(\n      cells_column_labels(\n        columns = gt::everything()\n      )\n    )\n  )\n# Output the sum table from this week in order to make comparisons to next week's table\nfwrite(sum_table_raw,file= paste0(\"\", today(), \".csv\"))\n```\n:::\n\n\n\n\n\n## GISAID flags and Graph\n## Output a list of SEQUENCE_REASON == NULL by month/year\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nreason_null <- final[which(str_detect(final$flag,\"SEQUENCE_REASON is NULL\")),]\nreason_count <-  reason_null %>%\n  # filter(year == '2021' | year == '2022')%>%\n  group_by(month, year) %>%\n  count() %>%\n  pivot_wider(names_from = year,values_from = n)%>%\n  adorn_totals(\"row\")%>%\n  mutate_if(is.numeric, ~replace_na(., 0))%>%\n  select(month,'2020','2021','2022')\nreason_count_table<- gt(reason_count) %>%\n  cols_label(month = \"Month\") %>%\n  tab_header(title = md(\"Count of Missing SEQUENCE_REASON by Month/Year\")) %>% \n  #Add a data source footnote\n  tab_source_note(source_note = \"*Year is derived from SPECIMEN_COLLECTION_DATE. If missing, CREATE_DATE is used\")%>%\n  data_color(columns= c('2020','2021'),\n             colors=scales::col_numeric(palette = c(\"#FFFFFF\",viridis(350,alpha=1,begin=0,end=1,direction=-1)),domain=NULL ))%>%\n  #All column headers are capitalised\n  opt_all_caps() %>% \n  #Use the Chivo font\n  #Note the great 'google_font' function in 'gt' that removes the need to pre-load fonts\n  opt_table_font(\n    font = list(\n      google_font(\"Chivo\"),\n      default_fonts()\n    )\n  ) %>%\n  tab_options(\n    #Remove border between column headers and title\n    column_labels.border.top.width = px(3),\n    column_labels.border.top.color = \"black\",\n    #Remove border around table\n    table.border.top.color = \"black\",\n    table.border.bottom.color = \"black\",\n    #Reduce the height of rows\n    data_row.padding = px(3),\n    #Adjust font sizes and alignment\n    source_notes.font.size = 12,\n    heading.align = \"left\"\n  ) %>%\n  fmt(\n    columns = everything(),\n    fns = function(x) ifelse(x == 0, \"—\",x)\n  )\n```\n:::\n\n\n\n\n\n# Flag CSV Output\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfinal_csv <- final %>%\n  select(-dplyr::ends_with('_warn'),\n         -failedflag,\n         -dplyr::starts_with('SEQUENCE'),\n         flag,\n         -n)\n  \n# Save the csv with all the errors\nfwrite(final_csv,file= paste0(\"\", today(), \".csv\"))\n```\n:::\n\n\n\n\n\n# Auto Email \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# import the plots - formats get destroyed in outlook, but it's good enough. If you open the outlook email into a web browser the formatting will work.\nsum_table_email <- as_raw_html(sum_table)\nreason_table_email <- as_raw_html(reason_count_table)\ngisaid_plot_email <- add_ggplot(GISAID_flag_plot1,width = 7,height = 6.5)\n# Make the email body - make updates to email here if needed\nmessage_body <-\n  glue::glue(\n\"Good Afternoon,\nHere are the results from the sequencing WDRS QA logic checks/duplicate checks from today {Sys.Date()}:\n\nHere’s a summary of errors found:\n{sum_table_email}\n\n{reason_table_email}\n\n{gisaid_plot_email}\nThanks,\nDIQA\nps - I'm a bot, bleep bloop\"\n)\nemail <- blastula::compose_email(body = md(message_body))\n# Sending email by SMTP using a credentials file\nemail %>%\n  smtp_send(\n    to = c(\"\"),\n    from = \"\",\n    subject = \"Sequencing QA - WDRS Logic Check Results\",\n    credentials = creds_key(id = \"\")\n  )\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}