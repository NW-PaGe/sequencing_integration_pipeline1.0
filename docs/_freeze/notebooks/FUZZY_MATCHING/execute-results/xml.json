{
  "hash": "657fbb8282cdd0d7de19310545484c0d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"FUZZY_MATCHING\"\nauthor: \"Emily Nebergall and Allie Warren\"\ndate: \"2024-03-01\"\noutput: html_document\n---\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nknitr::opts_chunk$set(eval = FALSE)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Introduction \n\nThe COVID Sequencing project matches lab-submitted COVID test sequencing records with WDRS COVID test result records. Usually this matching process is accomplished by matching clinical accession numbers that are assigned to COVID test specimens by the testing lab and which remain attached to the specimen through the sequencing process. However, some sequencing records are submitted without the clinical accession number, or the clinical accession number that accompanies the sequencing record does not match any COVID test specimen clinical accession in the WDRS Flattened or Entire tables. For sequencing records that cannot match to a test specimen in WDRS via a clinical accession specimen id, patient demographics provide an alternative matching option.\n\nThe FUZZY_MATCHING script uses `fuzzyjoin::stringdist_left_join()` to perform [optimal string alignment](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) on patient name and date of birth data to match lab-submitted sequencing data to COVID test specimen records in the WDRS Flattened and Entire tables. \n\n# Setup {.tabset}\n\n## Libraries\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\nlibrary(here)\nlibrary(lubridate)\nlibrary(readxl)\nlibrary(DBI)\nlibrary(odbc)\nlibrary(dtplyr)\nlibrary(fs)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Important Objects\n\nThis script uses several custom functions which are shared by other scripts in the Sequencing project. These shared custom functions are stored in the quality_filters.R script, which is called here using the `source()` function. The script also uses a table of \n\nThree sources of data are imported into this script. Valid lineage data is brought into help assure data quality. Submitter sequencing records are imported from the Submissions/Fuzzy_Match/ subdirectory of `project_folder`, either the project directory on the Y drive (test mode = FALSE) or the same folder in a local clone (test mode = TRUE). And finally, WDRS is queried for COVID test records which must be matched to the new sequencing data. \n\nVOC.RDS contains the list of variants of concern and is needed to populate the SEQUENCE_VARIANT column. The lineages object is updated [how often] by the _________________ script. VOC.RDS is declared in the .gitignore file as the only .RDS object allowed to pass to GitHub, as it does not contain any secrets, and it must be updated in order for roster-generating scripts to run properly.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# read in r_creds.RDS\nr_creds <-readRDS(file.path(Sys.getenv(\"USERPROFILE\"), \"Projects/Sequencing/Data_Objects\", \"r_creds.RDS\"))\n\n# Read in quality_filters\nsource(file.path(Sys.getenv(\"USERPROFILE\"), \"Projects/Sequencing/Roster_scripts/quality_filters.R\"))\n\n# Read in functions for performing fuzzy matching\nsource(file.path(Sys.getenv(\"USERPROFILE\"), \"Projects/Sequencing/Roster_scripts/fuzzy_matching_functions.R\"))\n\n# shared lab variable lists\nlab_vars <- readRDS(\"Data_Objects/lab_variables.rds\")\n\nvoc <- readRDS(\"Data_Objects/VOC/VOC.Rds\")\n\nlineages <- read_csv(\"Data_Objects/Lineages/Lineages.csv\") %>%\n  select(lineages = lineage_extracted)\n\nvalid_lineages <- lineages$lineages\n\n# Appending Unassigned lineage to avoid for review\nvalid_lineages <- c(\n  valid_lineages, \n  \"UNASSIGNED\",\n  \"Unassigned\"\n)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Submitter data\n\nData for fuzzy matching gets sent to the Fuzzy_Match folder in the Submissions subdirectory of the sequencing project. Each run of this script produces a saved_rows.csv file which contains rows that were not printed to any other file during the course of the run. While efforts are made to capture and funnel all of the data to some product in this script, this matching process is complex and saved_rows serves as a safety net to prevent data loss. saved_rows and the new files sent to fuzzy matching from the PHL and TEMPLATE_SUBMITTERS scripts are imported using `readr::read_csv()`, and compiled using `plyr::rbind.fill()`. Base R's `unique()` removes duplicate rows, which may occur when cumulative files such as the PHL download are run repeatedly through a transformation script before this fuzzy matching process is performed. \n\nFiles imported in this code chunk are combined using `plyr::rbind.fill()` because at the time of writing this script, data sent from the template submitters and PHL processes were producing different sets of columns. the `rbind.fill()` function allows for two files with slightly different column to be combined; all the columns will be preserved and blank cells will be added for rows that did not originally contain columns from the other files. \n\nAs a part of this data import, a unique row id is assigned using `tibble::rowid_to_column()` to avoid generating duplication events when records lack any unique identifier such as a sequence clinical accession or sequence accession, as sometimes happens when failed sequencing records (which do not require a sequence accession) also lack a sequence clinical accession. \n\n**rows_printed**: the empty object rows_printed is created here. Throughout the script, this object will receive the rowid's of records that are printed to any file. This conveniently allows us to see (if running the script manually) how many rows fall to each of the various output. At the end of the script, any records from the original input data whose rowid is NOT in rows_printed is passed to a saved_rows file which is printed to a subfolder of the fuzzy matches submissions folder and read into the next fuzzy matching session. This file is almost always empty, but it is beneficial to regularly check it to see if and how many records are not being captured by the script. This may indicate some change in the submitter data being received. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# a list of the columns we want to bring into this process\n# input columns for fuzzy matching data\nfuzz_cols <- c(\"SEQUENCE_REASON\",\n      \"GISAID_ID\",\n      \"PANGO_LINEAGE\",\n      \"FIRST_NAME\",\n      \"LAST_NAME\",\n      \"MIDDLE_NAME\",\n      \"SUBMITTING_LAB\",\n      \"DOB\",\n      \"SPECIMEN_COLLECTION_DATE\",\n      \"SEQUENCE_STATUS\",\n      \"ALTERNATIVE_ID\",\n      \"LAB_ACCESSION_ID\")\n\n# rows from the previous fuzzy match run that were not printed to any other file; a safety net to prevent data loss\nsaved_rows_file <- dir_ls(\"Submissions/Fuzzy_Match/rows_not_yet_printed\")\nif(length(saved_rows_file) > 0) {\n  saved_rows <- saved_rows_file %>%\n    map_df( ~ read_csv(\n      .,\n      col_types = cols(\n        SEQUENCE_REASON = col_character(),\n        GISAID_ID = col_character(),\n        PANGO_LINEAGE = col_character(),\n        FIRST_NAME = col_character(),\n        LAST_NAME = col_character(),\n        MIDDLE_NAME = col_character(),\n        SUBMITTING_LAB = col_character(),\n        DOB = col_character(),\n        SPECIMEN_COLLECTION_DATE = col_character(),\n        SEQUENCE_STATUS = col_character(),\n        ALTERNATIVE_ID = col_character(),\n        LAB_ACCESSION_ID = col_character()\n      )\n    )\n    ) %>%\n      plyr::rbind.fill() %>%\n    select(all_of(fuzz_cols)) %>%\n    unique()\n  # if no inputs here, inititalize empty data frame\n} else {\n  saved_rows <- data.frame(matrix(ncol=length(fuzz_cols), nrow = 0)) %>% magrittr::set_colnames(fuzz_cols)\n}\n\n# new files produced by the PHL and template submitter script\nfuzz_new_file <- dir_ls(\"Submissions/Fuzzy_Match\", type = \"file\")\nif(length(fuzz_new_file) > 0) {\n  fuzz_new <- fuzz_new_file %>%\n    map_df( ~ read_csv(\n      .,\n      col_types = cols(\n        SEQUENCE_REASON = col_character(),\n        GISAID_ID = col_character(),\n        PANGO_LINEAGE = col_character(),\n        FIRST_NAME = col_character(),\n        LAST_NAME = col_character(),\n        MIDDLE_NAME = col_character(),\n        SUBMITTING_LAB = col_character(),\n        DOB = col_character(),\n        SPECIMEN_COLLECTION_DATE = col_character(),\n        CASE_ID = col_character(),\n        SEQUENCE_STATUS = col_character(),\n        ALTERNATIVE_ID = col_character(),\n        LAB_ACCESSION_ID = col_character()\n      )\n    )\n    ) %>%\n      plyr::rbind.fill() %>%\n    select(all_of(fuzz_cols)) %>%\n    unique()\n  # if not inputs. initialize empty data frame\n} else {\n  fuzz_new <- data.frame(matrix(ncol=length(fuzz_cols), nrow = 0)) %>% magrittr::set_colnames(fuzz_cols)\n}\n\n# rbind.fill() adds saved_rows to the fuzz_new file, allowing for columns to be different between files. \n# create a unique row id using the index\nfuzz <- fuzz_new %>% plyr::rbind.fill(saved_rows) %>%\n  unique() %>%\n  tibble::rowid_to_column()\n\nrows_printed <- c()\n\nprint(nrow(fuzz))\n\n# If no records for fuzzy matching, send out the email and \n# stop the script\nif(nrow(fuzz) == 0) {\n     sendmailR::sendmail(\n    from = \"\",\n    to = c(\n      \"\"\n    ),\n    subject = \"Sequencing - COVID Sequencing Fuzzy Match script complete\",\n    msg = paste0(\"Fuzzy matching script for \", today(), \" is complete, there were no inputs to fuzzy matching.\"),\n    headers = list(\"Reply-To\" = \"\"),\n    control = list(smtpServer = \"\")\n  )\n  \n  stop(\"No inputs to fuzzy matching\")\n}\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## WDRS Data\n\n### Open connection to WDRS\n\n**IMPORTANT** the variables used to connect to WDRS are held within conn_list.RDS. All .RDS objects in this repository except for VOC.RDS are excluded from Git commits by declaring *.RDS in the .gitignore file because they are often used to hold our \"secrets\" such as credential and server connections. \n\nWe do not include server connections in code uploaded to GitHub. **WHY?** We have been asked by HTS to ensure our use of GitHub does not raise any security red flags. This server is an internal server containing confidential/restricted PHI. We want to hide this server information to reduce our possible “attack surface”. This connection may seem benign but it tells someone information they can use to \"hack\" into WDRS. SQL Server Native Client is now deprecated software and version 11 was the last release. Unsupported software is at higher risk of having security breaches. Additionally, someone would know the server name. \n\n**So: DO NOT alter the code used to open the connection to WDRS in any way that creates a security risk. Continue to treat this connection as a secret and store its variables in a .RDS object (or other external object that is excluded from Git commits) rather than calling them directly here.**\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# connect\nconnection <- DBI::dbConnect(odbc::odbc(), \n                             Driver = r_creds$conn_list[1], \n                             Server = r_creds$conn_list[2], \n                             Database = r_creds$conn_list[3], \n                             Trusted_connection = r_creds$conn_list[4], \n                             ApplicationIntent = r_creds$conn_list[5])\n```\n:::\n\n\n\n\n\n\n\n\n\n\n### WDRS Entire table\n\nWDRS demographics data for fuzzy matching\n\nThere are two different types of columns where name data is found in the entire table. The data is pulled into R using a SQL query. The custom function annihilate cleans the data to remove floating initials, punctuation, and extra spaces; check the Important Functions Wiki page in the repository for more information. \n\nPATIENT__FIRSTNAME and FIRST_NAME (substitute LAST for last names) are both filled with patient name data, and sometimes a name is found in one column but not in another. Therefore, both columns are queried. In the code chunk 'wdrs names' below 'wdrs_entire', a single name column is created by filling in missing data with data present in the alternate column. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# wdrs_entire <- xfun::cache_rds({\n  wdrs_entire <- dbGetQuery(\n    connection,\n    \"SELECT Distinct CASE_ID,\n      [PATIENT__FIRSTNAME] as FNAME,\n      [PATIENT__LASTNAME] as LNAME,\n      [FILLER__ORDER__NUM] as SpecimenId,\n      [PATIENT__DATE__OF__BIRTH] as DOB_WDRS,\n      [SPECIMEN__COLLECTION__DTTM] as COLLECTION_DATE_WDRS,\n      [FIRST_NAME] as FIRST_NAME,\n      [LAST_NAME] as LAST_NAME\n  FROM [dbo].[DD_ELR_DD_ENTIRE] WHERE CODE = 'SARS'\n  AND STATUS != '6' \n  AND WDRS__RESULT__SUMMARY != 'NEGATIVE'\"\n  ) \n\n  # clean up WDRS names, remove characters that are not alphanumeric, remove white spaces\n  wdrs_entire_names <- wdrs_entire %>%\n    mutate(FNAME = annihilate(wdrs_entire$FNAME),\n           LNAME = annihilate(wdrs_entire$LNAME),\n           SpecimenId = as.character(SpecimenId),\n           FIRST_NAME = annihilate(wdrs_entire$FIRST_NAME),\n           LAST_NAME = annihilate(wdrs_entire$LAST_NAME)) %>%\n    unite(NAME_WDRS,\n          c(FNAME, LNAME),\n          remove = TRUE,\n          na.rm = TRUE) %>%\n    unite(ALT_NAME_WDRS,\n          c(FIRST_NAME, LAST_NAME),\n          remove = TRUE,\n          na.rm = TRUE)\n  \n# },\n# rerun = FALSE,\n# file = \"wdrs_query\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Combine PATIENT NAME and NAME columns\nwdrs_entire <- wdrs_entire_names %>%\n   mutate(NAME_WDRS = case_when(\n      NAME_WDRS == \"\" ~ ALT_NAME_WDRS,\n      NAME_WDRS != \"\" ~ NAME_WDRS)\n      )\n\n# Get records where the PATIENT NAME and NAME columns differ\nalt_wdrs_name <- filter(wdrs_entire, NAME_WDRS != ALT_NAME_WDRS) %>%\n  mutate(NAME_WDRS = ALT_NAME_WDRS)\n\n# Add rows using the alternate name, duplicating the other columns\nwdrs_entire <- rbind.data.frame(wdrs_entire, alt_wdrs_name)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n### WDRS Flattened table\n\nSequencing results are entered into the flattened table, tied to the CASE_ID from the COVID test record found in the entire table. In order to prevent the entry of duplicate records to WDRS, we query the flattened table for sequence accession numbers tied to COVID test record CASE_ID's, and use these data to deduplicate input data that may have been submitted repeatedly. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# wdrs_sa_flat <- xfun::cache_rds({\n  wdrs_sa_flat <- dbGetQuery(\n    connection,\n    \"SELECT DISTINCT CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n     CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,\n     CASE_ID,\n     BIRTH_DATE\n     FROM [dbo].[DD_GCD_COVID_19_FLATTENED]\n     \"\n  )\n  \n# },\n# file = \"wdrs_sa_flat\")\n  \n# for fields that have multiple comma separated SEQUENCE_ACCESSION's split them by \",\"\nwdrs_sa_flat_split <- unlist(str_split(wdrs_sa_flat[[1]], \",\"))\n\n# omit any NA's\nwdrs_sa_flat_clean <-\n  wdrs_sa_flat_split[!is.na(wdrs_sa_flat_split)] %>%\n  #for fields that have \"hCoV-19/\" appended to the beginning of the SEQUENCE_ACCESSION remove it by str_replace() with \"\"\n  str_replace(\"hCoV-19/\", \"\") %>%\n  # trim off the white space resulting from str_split, this also gets rid of \" \" values\n  str_trim(\"both\")\n\n# remove any values that are \"\"\nwdrs_sa_flat_values <-\n  wdrs_sa_flat_clean[wdrs_sa_flat_clean != \"\"]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# for fields that have multiple comma separated SEQUENCE_ACCESSION's split them by \",\"\nwdrs_sca_flat_split <- unlist(str_split(wdrs_sa_flat[[2]], \",\"))\n\n# omit any NA's\nwdrs_sca_flat_clean <- wdrs_sca_flat_split[!is.na(wdrs_sca_flat_split)] %>%\n#for fields that have \"hCoV-19/\" appended to the beginning of the SEQUENCE_ACCESSION remove it by str_replace() with \"\"\n  str_replace(\"hCoV-19/\", \"\") %>%\n# trim off the white space resulting from str_split, this also gets rid of \" \" values  \n  str_trim(\"both\")\n\n# remove any values that are \"\"\nwdrs_sca_flat_values <- wdrs_sca_flat_clean[wdrs_sca_flat_clean != \"\"]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# some records in the WDRS ENTIRE table don't have a DOB, but that data is present for matching records \n# in the WDRS flattened table - replace DOB data with data from flattened table\n\nwdrs_entire <- left_join(wdrs_entire, wdrs_sa_flat, by = 'CASE_ID')\n\nwdrs_entire <- wdrs_entire %>% \n  mutate(DOB_WDRS = case_when((is.na(DOB_WDRS) & !is.na(BIRTH_DATE)) ~ BIRTH_DATE,\n                              TRUE ~ DOB_WDRS)) \n\n# if the WDRS entire and WDRS flattened table have different DOB, add a duplicate record with the alternate DOB (same method used for alt name)\n# Get records where the DOB_WDRS and BIRTH_DATE columns differ\nalt_wdrs_dob <- filter(wdrs_entire, DOB_WDRS != BIRTH_DATE) %>%\n  mutate(DOB_WDRS = BIRTH_DATE)\n\n# Add rows using the alternate name, duplicating the other columns, remove unused columns\nwdrs_entire <- rbind.data.frame(wdrs_entire, alt_wdrs_dob) %>% select(-CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,\n                                                           -CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER, -BIRTH_DATE)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n# Initial Quality Checks {.tabset}\n\n## Fixing SA Format\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# format GISAID ID - removing hcov-19 from the SA\nfuzz_fix_sa_format <- fuzz %>%\n  mutate(GISAID_ID = str_replace(GISAID_ID, \"hCoV-19/\", \"\"))\n\n#code to remove sequence accessions with a bad format that was encountered with LabCorp specimens for a short time; obsolete, retaining in case of re-occurance\n# fuzz_clean <- fuzz %>%\n#   filter(!(GISAID_ID %in% wdrs_sa_flat_values),\n#          !(str_detect(GISAID_ID, \"USA/WA-CDC-WA-CDC-*\")))\n# \n# fuzz_wrong <- fuzz %>%\n#   filter(str_detect(GISAID_ID, \"USA/WA-CDC-WA-CDC-*\")) \n\n# \n# # if(nrow(fuzz_wrong) > 0) {\n# #   write_csv(fuzz_wrong, paste0(project_folder, \n# #                                       \"//Fuzzy_matches//Fuzzy_Error_Checks//fuzzy_bad_SA_format_\", \n# #                                       today(), \n# #                                       \".csv\"))\n# #   \n# #   rows_printed <- rows_printed %>% append(fuzz_wrong$rowid)\n# #   \n# #   print(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n# # }\n# \n# \n# \n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Missing Demographics\n\nBefore data can be filtered, one correction to date data for birth dates must be made. Excel dates have arrived in the birth date column and are not transformed to any known format in R when the file is read in using read_csv. The custom function `convert_excel_date()` transforms these 4-5 digit strings to mm-dd-yyyy format. See the Important Functions Wike page for more details. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#transform dates that are in excel format to yyyy-mm-dd. keep NA rows so that they are filtered along with other preprocessing errors\n\nfuzz_fix_excel_dates <- fuzz_fix_sa_format %>%\n  mutate(DOB = case_when(detect_date_format(DOB) ~ as.character(DOB),\n                         str_detect(DOB, \"^[[:digit:]]{4,5}$\") ~ as.character(convert_excel_date(DOB)),\n                         TRUE ~ DOB))\n#   \n# }\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Pre-Match Quality Checks\n\nColumns are added to the data that check for specific errors and add a 1 to the rows where the error check is positive. These error checks include the relevant checks from the `roster_filters()` function; see the Important Functions Wiki page for more details. It is important to note that the deduplication process for Fuzzy Matching does not involved the Sequence Clinical Accession as many rows arrive here without that identifier. We do however deduplicate both internally and against WDRS by sequence accession. \n\nRows with positive errors are filtered out at the end of this error check process and sent to For_Review/to_process_fuzzy_match/fuzzy_pre_match_quality_filter_today.csv\"\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# create columns for each condition that must be met in order for the data to be rostered to wdrs\n\n\n\nfuzzy_pre_match_quality <- fuzz_fix_excel_dates %>%\n  mutate(SEQUENCE_REASON = toupper(SEQUENCE_REASON))%>%\n  mutate(SEQUENCE_STATUS = if_else(str_detect(PANGO_LINEAGE,\"Unas\"),\"LOW QUALITY\",toupper(SEQUENCE_STATUS)))%>%\n  mutate(\n    # check that GISAID_ID (sequence accession) doesn't show up more than once\n    QA_SA_INT_DUPE = case_when(!(is.na(GISAID_ID) | GISAID_ID == \"\") & \n                                        GISAID_ID %in% GISAID_ID[duplicated(GISAID_ID)] ~ 1),\n    # check that GISAID_ID (sequence accession) isn't already in WDRS\n    QA_SA_WDRS_DUPE = case_when(GISAID_ID %in% wdrs_sa_flat_values ~ 1),\n    # check that lineage is not NA or None and is in expected list\n    QA_SEQ_VARIANT = case_when(str_detect(toupper(PANGO_LINEAGE), \"NONE|^NA\") |\n                                      (!PANGO_LINEAGE %in% valid_lineages &\n                                         !(is.na(PANGO_LINEAGE) | PANGO_LINEAGE == \"\")) ~ 1),\n    # check that sequence status is COMPLETE, FAILED, or LOW QUALITY and\n    # that GISAID_ID (sequence accession) exists/doesn't exist for various statuses\n    QA_SEQ_STAT = case_when(is.na(SEQUENCE_STATUS) ~ 1,\n                            !SEQUENCE_STATUS %in% c('COMPLETE', 'FAILED', 'LOW QUALITY') ~ 1,\n                                   # error when status is complete but sa is missing,\n                                   SEQUENCE_STATUS == \"COMPLETE\" & (is.na(GISAID_ID) | GISAID_ID == \"\") ~ 1,\n                                    # error when status is not complete and sa is not missing\n                                    SEQUENCE_STATUS %in% c(\"FAILED\",\n                                                           \"NOT DONE\",\n                                                           \"HIGH CT\") & !(is.na(GISAID_ID) | GISAID_ID == \"\") ~ 1),\n    # check that sequence reason is valid for the submitting lab\n    QA_SEQ_REASON = case_when(SUBMITTING_LAB %in% lab_vars$cdc_labs & !(SEQUENCE_REASON %in% lab_vars$input_seq_reasons_cdc) |\n        (!(SUBMITTING_LAB %in% c(lab_vars$cdc_labs, \"PHL\")) & !(SEQUENCE_REASON %in% lab_vars$input_seq_reasons_non_cdc)) |\n        (SUBMITTING_LAB == \"PHL\" & !(SEQUENCE_REASON %in% lab_vars$input_seq_reasons_phl))\n       ~ 1),\n    # check that lineage exists/does not exist for various sequence statuses\n    QA_SEQ_NOTES = case_when((SEQUENCE_STATUS == \"COMPLETE\") &\n                                       (is.na(PANGO_LINEAGE)) ~ 1,\n                             (SEQUENCE_STATUS == \"FAILED\") &\n                                         (PANGO_LINEAGE != \"\") ~ 1),\n    # check that record has name\n    QA_NAME_NA = case_when(is.na(FIRST_NAME) & is.na(LAST_NAME) & is.na(MIDDLE_NAME) ~ 1,\n                           str_detect(FIRST_NAME,\"[[:digit:]]\") | str_detect(LAST_NAME,\"[[:digit:]]\") | str_detect(MIDDLE_NAME,\"[[:digit:]]\") ~ 1),\n    # check that record has DOB and is in the correct format\n    QA_DOB_NA = case_when(is.na(DOB) ~ 1,\n                          DOB == \"1899-12-30\" ~ 1,\n                          !detect_date_format(DOB) ~ 1),\n    # check that record has collection date and is in the correct format\n    QA_COLLECT_DATE_NA = case_when(is.na(SPECIMEN_COLLECTION_DATE) ~ 1,\n                                   is.na(lubridate::parse_date_time(SPECIMEN_COLLECTION_DATE, orders = c(\"mdY\", \"ymd\", \"Ymd\"))) ~ 1)\n  )  %>% \n  rowwise() %>%\n  mutate(sum = sum(\n    c_across(QA_SA_INT_DUPE:QA_COLLECT_DATE_NA),\n    na.rm = TRUE\n  ))\n\n# print a table with sums of each error column for visibility\n\nquality_check <- fuzzy_pre_match_quality %>% \n  select(QA_SA_INT_DUPE:QA_COLLECT_DATE_NA) %>%\n  colSums(na.rm = TRUE)\n\nquality_check\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Print Pre-Match Errors\n\nAt this point, we will filter and print all records that generated a positive result for any of the error checks in the previous section. At this point, we will have captured the following errors in the data:\n\n- GISAID_ID (sequence accession) doesn't show up more than once\n- GISAID_ID (sequence accession) isn't already in WDRS\n- lineage is not NA or None and is in expected list\n- sequence status is COMPLETE, FAILED, or LOW QUALITY (not missing or other than one of these)\n- GISAID_ID (sequence accession) exists or doesn't exist according to the logic for sequence statuses: if COMPLETE, GISAID_ID is present. If LOW_QUALITY, GISAID_ID may or may not be present. If FAILED, GISAID_ID is not present. Code also applies this check to statuses \"HIGH CT\" and \"NOT DONE\", although either of these statuses will also be caught as an error because the only status permitted for invalid sequence results should be 'FAILED\". \n  - error when status is complete but sa is missing\n  - error when status is not complete and sa is not missing\n- sequence reason is valid for the submitting lab\n- lineage exists or does not exist according to the logic for sequence statuses\n- patient name is not missing\n- DOB is not missing and is in a correct date format, and is NOT 1899-12-31, which may result when an excel date of 00000 is converted to yyyy-mm-dd\n- specimen collection date is not missing and is in the correct format  \n\nfuzz_good_rows is the dataframe used to create rosters. We create it by filtering out all rows that generated an error, leaving behind only clean data. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# print a file containing rows with errors\nfuzz_bad_rows <- fuzzy_pre_match_quality %>% \n  filter(sum > 0)\n\nif(nrow(fuzz_bad_rows) > 0) {\n    write_csv(fuzz_bad_rows %>% select(-sum, -rowid), file.path(\n    \"For_Review/to_process_fuzzy_match\",\n      paste0(\"fuzzy_pre_match_quality_filter_\",\n      today(),\n      \".csv\"\n    )\n    ), na = \"\"\n  )\n  \n  rows_printed <- rows_printed %>% append(fuzz_bad_rows$rowid)\n  print(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n}\n\n# split out the good data and pass it through to the rest of the script\nfuzz_good_rows <- fuzzy_pre_match_quality %>%\n  filter(sum == 0)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Clean Data Sent to Rosters\n\nfuzz_good_rows receives two final transformations before it is matched to WDRS data. \n\nThe custom `annihilate()` function is applied to FIRST_NAME and LAST_NAME from submitter data to produce names in a standardized format (example: JANE_DOE). See the Important Functions Wiki page for details about custom functions. \n\nThe DOB and SEQUENCE_SPECIMEN_COLLECTION_DATE columns are transformed to a uniform yyyy-mm-dd format. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy_match_initial <- fuzz_good_rows %>% mutate(\n  FNAME = annihilate(FIRST_NAME),\n  LNAME = annihilate(LAST_NAME),\n  DOB_SUBMITTER = lubridate::parse_date_time(DOB, orders = c(\"mdY\", \"ymd\", \"Ymd\")),\n  SEQUENCE_SPECIMEN_COLLECTION_DATE = lubridate::parse_date_time(SPECIMEN_COLLECTION_DATE, orders = c(\"mdY\", \"ymd\", \"Ymd\"))\n  ) %>%\n  unite(NAME_SUBMITTER,\n        c(FNAME, LNAME),\n        remove = TRUE,\n        na.rm = TRUE) %>%\n  select(\n    rowid,\n    NAME_SUBMITTER,\n    GISAID_ID,\n    SEQUENCE_SPECIMEN_COLLECTION_DATE,\n    DOB_SUBMITTER,\n    PANGO_LINEAGE,\n    SEQUENCE_REASON,\n    SEQUENCE_STATUS,\n    SUBMITTING_LAB,\n    LAB_ACCESSION_ID\n  ) %>%\n  unique()\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n# Fuzzy matching\n\nInexact matching between WDRS and submitter data relies on patient first and last name and date of birth. Additional matching based on specimen collection date is carried out after the initial matches based on demographics are identified. \n\nFirst, records are grouped by the year of the date of birth of the patient, extracted from the DOB_SUBMITTER column for submitter data and the DOB_WDRS column for WDRS data to be matched. \n\nAn alternative name column is created for the submitter data, consisting of name data flipped so that the order of the names is last_first. Sometimes the name order in either submitter or wdrs data is flipped and so we match on both name orders to capture these instances. \n\nSubmitter data is split into a list of dataframes, each list containing records of patients grouped by the year of their birth. \n\nThe custom `fuzzy_match_name_flip()` function is applied to this list of submitter records. This function first blocks the data based on the birth year of the patient, splitting out WDRS records where the birth year of the patient matches the birth year of the submitter records to be matched. Then the function applies `stringdist_left_join()`, which matches names using [optimal string alignment](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) to look for near matches. The output includes a distance column with data on the distance between the submitter and WDRS names for matched records. A maximum distance of 3 characters is allowed here. \n\nAdditional matching columns are provided to allow filtering on matching date of birth and matching specimen collection date. Because we have noticed date of birth errors and unreliable specimen collection date data, we generate files for manual review that contain rows unable to be matched perfectly to WDRS using name and date of birth. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Block input on DOB year to reduce possible matches, and improve speed\n# Break input into groups of records with the same DOB year\n# and use parallelization to run fuzzy matching across each of these groups\nwdrs_entire$year <- lubridate::year(wdrs_entire$DOB_WDRS)\nfuzzy_match_initial$year <- lubridate::year(fuzzy_match_initial$DOB_SUBMITTER)\n\n# Create groups based on DOB year\nfuzzy_match_initial <- fuzzy_match_initial %>%                                        \n  group_by(year) %>%\n  dplyr::mutate(group_num = cur_group_id())\n\n# Add second version of the name with first and last name switched to account\n# for switching of fields\nfuzzy_match_initial$NAME_SUBMITTER_2 <- paste0(str_replace(fuzzy_match_initial$NAME_SUBMITTER, \".*_\", \"\"),\n                                               \"_\", str_replace(fuzzy_match_initial$NAME_SUBMITTER, \"_.*\", \"\"))\n\n# split input records into separate tables per group\nfuzzy_split <- split(fuzzy_match_initial, f = fuzzy_match_initial$group_num)\n\n# print size of each group\nlapply(fuzzy_split, dim)\n\n\n# apply the fuzzy matching function in parallel across 7 of 8 cores. Can use all cores if not performing other tasks. \nlibrary(parallel)\nnumCores  = round(parallel::detectCores() * .85)\ncl <- makePSOCKcluster(numCores)\n\n# export the necessary elements of the local environment to all the cores\nsystem.time(clusterExport(\n  cl = cl,\n  varlist = c(\"fuzzy_split\", \"wdrs_entire\"),\n  envir = .GlobalEnv\n))\n\n# Run fuzzy matching\nsystem.time(\n  fuzzy_matches_wdrs <- parLapply(cl, fuzzy_split, fuzzymatch_name_flip) %>%\n    bind_rows()\n)\n\nstopCluster(cl)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n# Transformations and Post-matching Quality Filters {.tabset}\n\nNow that the submitter records have been assigned possible matches from WDRS, we apply final transformations and split out matches that contain errors. \n\n## modify date types\n\nAll date types are converted to the roster date format mm/dd/yyyy\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy_matches_wdrs <- fuzzy_matches_wdrs %>% \n  mutate(COLLECTION_DATE_WDRS = as.character(format(\n    as.Date(COLLECTION_DATE_WDRS), \"%m/%d/%Y\"\n  ))) %>%\n  mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = as.character(format(\n    as.Date(SEQUENCE_SPECIMEN_COLLECTION_DATE), \"%m/%d/%Y\"\n  ))) %>%\n  mutate(DOB_SUBMITTER = as.character(format(\n    as.Date(DOB_SUBMITTER), \"%m/%d/%Y\"\n  ))) %>%\n   mutate(DOB_WDRS = as.character(format(\n    as.Date(DOB_WDRS), \"%m/%d/%Y\"\n  )))\n\nfuzzy_match_initial <- fuzzy_match_initial %>%\n   mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = as.character(format(\n    as.Date(SEQUENCE_SPECIMEN_COLLECTION_DATE), \"%m/%d/%Y\"\n  ))) %>%\n  mutate(DOB_SUBMITTER = as.character(format(\n    as.Date(DOB_SUBMITTER), \"%m/%d/%Y\"\n  )))\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Filter data on matching DOB\n\nOnly possible matches with a perfectly matched date of birth are accepted. We discard matches generated by the fuzzy matching function where the name was a match but the date of birth is different. \n\nThis filter is easy to apply now; date formats require no modification because they have already been cleaned. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# filter out rows that have a dob that doesn't match any matching demographic rows in WDRS\nfuzzy_dob_match <- fuzzy_matches_wdrs %>%\n  mutate(DOB_MATCH = case_when(DOB_SUBMITTER == DOB_WDRS ~ \"match\"))\n\nfuzzy_dob_filtered <- fuzzy_dob_match %>% filter(DOB_MATCH == 'match')\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## No CASE_ID assigned\n\nSome submitter records might not have been assigned any matches from WDRS. Here, we split out these records as well as records for which only \"bad\" (non-matched date of birth) matches were assigned to the object did_not_match and printed to the Fuzzy_Matches/ subdirectory using the `print_rosters()` function, after being transformed to roster format. \n\nthe `roster_filters()` function is not applied here, as the error checks it performs are redundant with checks performed earlier in this script. In order to facilitate the use of the `print_rosters()` function, a dummy \"sum\" column is supplied, populated with 0's. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# this code chunk uses the roster_filters() function, but it modifies the output heavily so that a file is printed that combines dob-missing or error rows and does not include errors that do not pertain to fuzzy matching or to this particular file. \n\n# print for review\ndid_not_match <- fuzzy_dob_match %>%\n  filter(is.na(CASE_ID) | is.na(DOB_MATCH),\n         !(rowid %in% fuzzy_dob_filtered$rowid))\n\ndid_not_match <- did_not_match %>%  mutate(\n    CASE_ID = \"\",\n    SEQUENCE_REASON = case_when(\n      (SUBMITTING_LAB %in% lab_vars$cdc_labs &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_cdc) ~ SEQUENCE_REASON,\n      (!(SUBMITTING_LAB %in% c(lab_vars$cdc_labs, \"PHL\")) &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_non_cdc) ~ SEQUENCE_REASON,\n      (SUBMITTING_LAB == \"PHL\" &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_phl) ~ SEQUENCE_REASON,\n      (SUBMITTING_LAB %in% c(lab_vars$cdc_labs, \"PHL\") &\n        SEQUENCE_REASON %in% lab_vars$seq_reason_sent_surveillance) ~ \"SENTINEL SURVEILLANCE\",\n      (SEQUENCE_REASON %in% lab_vars$seq_reason_outbreak) ~ \"OUTBREAK\"\n    ),\n    SEQUENCE_LAB = SUBMITTING_LAB,\n    SEQUENCE_SGTF = \"\",\n    SEQUENCE_SPECIMEN = \"YES\",\n    SEQUENCE_DATE = \"\",\n    SEQUENCE_REPOSITORY = \"GISAID\",\n    SEQUENCE_ACCESSION = case_when(SEQUENCE_STATUS == \"FAILED\" ~ \"\",\n                                   SEQUENCE_STATUS == \"COMPLETE\" ~ GISAID_ID),\n    SEQUENCE_CLINICAL_ACCESSION = as.character(LAB_ACCESSION_ID),\n    COLLECTION_DATE_WDRS = \"\",\n    SEQUENCE_REVIEWED = \"\",\n    SEQUENCE_EPI_ISL = \"\",\n    SEQUENCE_ROSTER_PREPARE_DATE = format(today(), \"%m/%d/%Y\")\n  ) %>%\n  mutate(SEQUENCE_VARIANT = case_when(PANGO_LINEAGE %in% voc ~ PANGO_LINEAGE,\n                                      TRUE ~ \"\")) %>%\n  mutate(SEQUENCE_NOTES = case_when(\n    !is.na(PANGO_LINEAGE) ~ paste0(\n      \"Lineage identified as \",\n      PANGO_LINEAGE,\n      \" on \",\n      today(),\n      \". Lineage assignments may change over time.\"\n    ),\n    is.na(PANGO_LINEAGE) ~ \"\"\n  )) %>%\n  mutate(Case.Note = \"Case created and sequence data added through manual process.\") %>%\n  mutate(NAME_SUBMISSION = NAME_SUBMITTER,\n         DISTANCE_NAME = \"\",\n         NAME_WDRS = \"\") %>%\n  mutate(SEQUENCE_VARIANT_OPEN_TEXT = PANGO_LINEAGE) %>%\n  mutate(sum = \"0\") %>%\n  select(\n    CASE_ID,\n    SEQUENCE_SGTF,\n    SEQUENCE_SPECIMEN,\n    SEQUENCE_DATE,\n    SEQUENCE_REASON,\n    SEQUENCE_LAB,\n    SEQUENCE_STATUS,\n    SEQUENCE_REPOSITORY,\n    SEQUENCE_ACCESSION,\n    SEQUENCE_EPI_ISL,\n    SEQUENCE_VARIANT_OPEN_TEXT,\n    SEQUENCE_CLINICAL_ACCESSION,\n    SEQUENCE_SPECIMEN_COLLECTION_DATE,\n    SEQUENCE_ROSTER_PREPARE_DATE,\n    SEQUENCE_NOTES,\n    SEQUENCE_REVIEWED,\n    Case.Note,\n    NAME_SUBMITTER,\n    DOB = DOB_SUBMITTER,\n    DISTANCE_NAME,\n    NAME_WDRS,\n    COLLECTION_DATE_WDRS,\n    rowid\n  ) %>%\n  unique() %>%\n  mutate(sum = 0)\n\n\nfuzzy_match_successful <- filter(fuzzy_dob_filtered, !rowid %in% did_not_match$rowid) %>%\n  select(-year.x, -year.y, -group_num)\n\nprint_roster(did_not_match, for_review = TRUE)\n\nfuzzy_match_successful_clean <- fuzzy_match_successful %>%\n  subset(!duplicated(fuzzy_match_successful %>% select(-NAME_WDRS)))\n\nrows_printed <- rows_printed %>% append(did_not_match$rowid)\nprint(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Fuzzy Roster Transformations\n\nHere, fuzzy match data is transformed to the schema that Data Support has agreed to review, and columns that belong in the roster are selected. \n\nThe lab_vars object contains a list of sequence reasons that are used here to assign sequence reasons matched to three different submitter categories. In order to understand these, inspect the lab_vars list pulled into the environment at the beginning of the script. \n\nAnother object used here that is imported from outside this script is the voc list of variants of concern. Visit the Lineages section of Import Data at the beginning of this script for details. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy_match_transform <- fuzzy_match_successful %>%\n  mutate(\n    SEQUENCE_REASON = case_when(\n      (SUBMITTING_LAB %in% lab_vars$cdc_labs &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_cdc) ~ SEQUENCE_REASON,\n      (!(SUBMITTING_LAB %in% c(lab_vars$cdc_labs, \"PHL\")) &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_non_cdc) ~ SEQUENCE_REASON,\n      (SUBMITTING_LAB == \"PHL\" &\n        SEQUENCE_REASON %in% lab_vars$output_seq_reasons_phl) ~ SEQUENCE_REASON,\n      (SUBMITTING_LAB %in% c(lab_vars$cdc_labs, \"PHL\") &\n        SEQUENCE_REASON %in% lab_vars$seq_reason_sent_surveillance) ~ \"SENTINEL SURVEILLANCE\",\n      (SEQUENCE_REASON %in% lab_vars$seq_reason_outbreak) ~ \"OUTBREAK\"\n    ),\n    SEQUENCE_LAB = SUBMITTING_LAB,\n    SEQUENCE_SGTF = \"\",\n    SEQUENCE_SPECIMEN = \"YES\",\n    SEQUENCE_DATE = \"\",\n    SEQUENCE_REPOSITORY = \"GISAID\",\n    SEQUENCE_ACCESSION = case_when(SEQUENCE_STATUS == \"FAILED\" ~ \"\",\n                                   SEQUENCE_STATUS == \"COMPLETE\" ~ GISAID_ID),\n    SEQUENCE_CLINICAL_ACCESSION = as.character(SpecimenId),\n    SEQUENCE_REVIEWED = \"\",\n    SEQUENCE_EPI_ISL = \"\",\n    SEQUENCE_ROSTER_PREPARE_DATE = format(today(), \"%m/%d/%Y\")\n  ) %>%\n  mutate(SEQUENCE_VARIANT = case_when(PANGO_LINEAGE %in% voc ~ PANGO_LINEAGE,\n                                      TRUE ~ \"\")) %>%\n  mutate(SEQUENCE_NOTES = case_when(\n    !is.na(PANGO_LINEAGE) ~ paste0(\n      \"Lineage identified as \",\n      PANGO_LINEAGE,\n      \" on \",\n      today(),\n      \". Lineage assignments may change over time.\"\n    ),\n    is.na(PANGO_LINEAGE) ~ \"\"\n  )) %>%\n  mutate(Case.Note = \"External data question package updated by COVID19 Sequencing Roster.\") %>%\n  mutate(NAME_SUBMISSION = NAME_SUBMITTER) %>%\n  mutate(SEQUENCE_VARIANT_OPEN_TEXT = PANGO_LINEAGE) %>%\n  select(\n    rowid,\n    CASE_ID,\n    SEQUENCE_SGTF,\n    SEQUENCE_SPECIMEN,\n    SEQUENCE_DATE,\n    SEQUENCE_REASON,\n    SEQUENCE_LAB,\n    SEQUENCE_STATUS,\n    SEQUENCE_REPOSITORY,\n    SEQUENCE_ACCESSION,\n    SEQUENCE_EPI_ISL,\n    SEQUENCE_VARIANT_OPEN_TEXT,\n    SEQUENCE_CLINICAL_ACCESSION,\n    SEQUENCE_SPECIMEN_COLLECTION_DATE,\n    SEQUENCE_ROSTER_PREPARE_DATE,\n    SEQUENCE_NOTES,\n    SEQUENCE_REVIEWED,\n    Case.Note,\n    COLLECTION_DATE_WDRS,\n    NAME_SUBMITTER,\n    DOB = DOB_SUBMITTER,\n    DISTANCE_NAME = distance,\n    NAME_WDRS\n  ) %>%\n  unique()\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Collection Date Filter {.tabset}\n\n### Filter Data on 14 Day Window\n\nNow that collection dates are formatted, the interval in days is calculated between WDRS and submitter sequencing data. Rows with collection dates outside 14 days are filtered and sent to a for review folder. For most of these, there will be another possible match where the collection date was within the acceptable window. We address records where there is only a mismatched collection date in the next section. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy_match_transform <- fuzzy_match_transform %>%\n  # calculate the interval in days between collection dates in submitter and wdrs data\n  mutate(int = interval(\n    mdy(SEQUENCE_SPECIMEN_COLLECTION_DATE),\n    mdy(COLLECTION_DATE_WDRS)\n  ),\n  COLLECTION_DATE_DISTANCE = time_length(int, unit = \"day\")) %>%\n  select(-c(int)) %>%\n  unique()\n\n# remove rows where the distance is greater than 14 days\nfuzzy_colldate_filtered <- fuzzy_match_transform  %>% \n  filter(!is.na(COLLECTION_DATE_DISTANCE) &\n           abs(COLLECTION_DATE_DISTANCE) <= 14 &\n           !is.na(SEQUENCE_SPECIMEN_COLLECTION_DATE))\n```\n:::\n\n\n\n\n\n\n\n\n\n\n### Collection Date Mismatch\n\nSome matched records with a collection date difference outside 14 days are the only available match for a sequencing result. We split these out for manual review so that they are not lost, and add them back to the data for filtering and rostering. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# get records where the specimen collection date and wdrs collection date\n# fell outside the 14 day window, and which are not recorded elsewhere\n\nfuzzy_colldate_mismatch <- fuzzy_match_transform %>%\nfilter(!rowid %in% fuzzy_colldate_filtered$rowid) %>%\n  unique()\n\n# add records with collection date mismatch and no other match back into the table of matches\nfuzzy_colldate_evaluated <- rbind(fuzzy_colldate_filtered, fuzzy_colldate_mismatch) %>% as.data.frame() %>%\n  mutate(QA_COLLECT_DATE = case_when(is.na(COLLECTION_DATE_DISTANCE) ~ 1,\n                                     abs(COLLECTION_DATE_DISTANCE) > 14 ~ 1)) \n```\n:::\n\n\n\n\n\n\n\n\n\n\nIf there are two possible matches with the same collection date and same case ID but different sequence clinical accessions, match to patient level (get rid of sequence clinical accession)\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy_sca_count <- fuzzy_colldate_evaluated %>% \n  group_by(CASE_ID, SEQUENCE_ACCESSION) %>%\n  summarise(count = n_distinct(SEQUENCE_CLINICAL_ACCESSION) )\n\n# join the counts back to the rest of the data\njoin_counts <- left_join(fuzzy_colldate_evaluated, fuzzy_sca_count, by = c(\"CASE_ID\", \"SEQUENCE_ACCESSION\"))  %>%\n  arrange(COLLECTION_DATE_DISTANCE) %>%\n  select(-COLLECTION_DATE_DISTANCE)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Case Counts\n\nIn cases where there are multiple sequence clinical accessions from WDRS are tied to a single unique case id + sequence accession combination, implying that the algorithm cannot distinguish between the sequence clinical accession is dropped and the record is matched to the patient level only. \n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# if there is >1 SCA per unique case_id + SA, remove all SCA from that case_id \nfuzzy_cleaned <- join_counts %>%\n  mutate(SEQUENCE_CLINICAL_ACCESSION = if_else(count > 1, \"\", SEQUENCE_CLINICAL_ACCESSION))\n\n# deduplicate the records so that they are matched to only the patient level, but keep the WDRS collection date for error checking\nfuzzy_cleaned <- fuzzy_cleaned[!duplicated(fuzzy_cleaned %>% select(-COLLECTION_DATE_WDRS)),]\n\nfuzzy_case_counts <-  fuzzy_cleaned %>%\n  subset(!duplicated(fuzzy_cleaned %>% select(rowid:Case.Note))) %>%\n  select(-count)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Print Rosters {.tabset}\n\nRosters are split out from fuzzy_case_counts based on match quality. \n\n## Perfect Matches\n\nSome of the rows that have been matched to case id's using demographics are ready to be sent to WDRS along with the rest of the roster. These are specimens where there is a perfect match between PHL and WDRS data for name, date of birth, and collection date of less than 14 days distance. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#perfect matches: send to write_roster_here\nfuzzy_matched_perfect <- fuzzy_case_counts %>%\n  # select only perfect name matches\n  filter(DISTANCE_NAME == 0) %>%\n  unique() %>% \n  mutate(QA_MULTIPLE_MATCH = case_when(rowid %in% rowid[duplicated(rowid)] ~ 1))\n\n# apply roster filters\nfuzzy_perfect <-fuzzy_matched_perfect %>%\n  rowwise() %>%\n    mutate(sum = sum(\n      c_across(QA_COLLECT_DATE:QA_MULTIPLE_MATCH),\n      na.rm = TRUE\n    )\n    ) \n  \nprint(fuzzy_perfect %>% \n    select(QA_COLLECT_DATE:QA_MULTIPLE_MATCH) %>%\n    colSums(na.rm = TRUE))\n\n# use the custom print_roster function; this will be modified to also print a roster of data with errors\n# Fuzzy perfects are sent to \"write_roster_here\" and will go through Roster Compile script\n# Fuzzy perfects with errors are sent to For_Review\nprint_roster(fuzzy_perfect, for_review = FALSE)\nprint_error_rows(fuzzy_perfect, roster_now = TRUE)\n\nrows_printed <- rows_printed %>% append(unique(fuzzy_perfect$rowid))\nprint(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n\n# remove matched records from table\nfuzzy_case_counts <- filter(fuzzy_case_counts, !rowid %in% fuzzy_perfect$rowid)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Fuzzy1\n\nRoster now: records with a name distance of 1 and a matching date of birth AND specimen collection date within the 14 day window. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# fuzzy 1 rows are rows where the best match was a name distance of 1\nfuzzy1 <- fuzzy_case_counts %>% filter(DISTANCE_NAME == 1) %>% \n  unique() %>%\n  # this is just for the convenience of anyone manually reviewing an output file to check matches\n  arrange(SEQUENCE_ACCESSION) %>%\n  mutate(QA_MULTIPLE_MATCH = case_when(rowid %in% rowid[duplicated(rowid)] ~ 1))\n\nfuzzy1_roster_now <- fuzzy1 %>% \n  rowwise() %>%\n    mutate(sum = sum(\n      c_across(QA_COLLECT_DATE:QA_MULTIPLE_MATCH),\n      na.rm = TRUE\n    )\n    )\n  \nprint(fuzzy1 %>% \n    select(QA_COLLECT_DATE:QA_MULTIPLE_MATCH) %>%\n    colSums(na.rm = TRUE))\n\n# Fuzzy1 records are sent to \"write_roster_here\" and will go through Roster Compile script\n# Fuzzy1 records with errors are sent to For_Review\nprint_roster(fuzzy1_roster_now, for_review = FALSE)\n\nprint_error_rows(fuzzy1_roster_now, roster_now = TRUE)\n\nrows_printed <- rows_printed %>% append(unique(fuzzy1_roster_now$rowid))\nprint(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n\n# remove matched records from table\nfuzzy_case_counts <- filter(fuzzy_case_counts, !rowid %in% fuzzy1_roster_now$rowid)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Fuzzy2\n\nRecords with a name distance of 2 will be sent to the fuzzy matches folder for manual review. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy2 <- fuzzy_case_counts %>% \n  filter(DISTANCE_NAME == 2) %>% \n    mutate(SEQUENCE_CLINICAL_ACCESSION = case_when(is.na(SEQUENCE_SPECIMEN_COLLECTION_DATE) ~ \"\")) %>%\n    mutate(SEQUENCE_ROSTER_PREPARE_DATE = format(today(), \"%m/%d/%Y\")) %>%\n    mutate(SEQUENCE_EPI_ISL = \"\") %>%\n  unique() %>%\n  arrange(SEQUENCE_ACCESSION) %>% \n  mutate(QA_MULTIPLE_MATCH = case_when(rowid %in% rowid[duplicated(rowid)] ~ 1)) %>%\n  rowwise() %>%\n    mutate(sum = sum(\n      c_across(QA_COLLECT_DATE:QA_MULTIPLE_MATCH),\n      na.rm = TRUE\n    )\n    )\n\nprint(fuzzy2 %>% \n    select(QA_COLLECT_DATE:QA_MULTIPLE_MATCH) %>%\n    colSums(na.rm = TRUE))\n\n\nprint_roster(fuzzy2, for_review = TRUE)\n\nprint_error_rows(fuzzy2)\n\nrows_printed <- rows_printed %>% append(unique(fuzzy2$rowid))\nprint(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n\n# remove matched records from table\nfuzzy_case_counts <- filter(fuzzy_case_counts, !rowid %in% fuzzy2$rowid)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Fuzzy3\n\nRecords with a name distance of 3 will be sent to the fuzzy matches folder for manual review. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfuzzy3 <- fuzzy_case_counts %>% \n  filter(DISTANCE_NAME == 3) %>% \n      mutate(SEQUENCE_CLINICAL_ACCESSION = case_when(is.na(SEQUENCE_SPECIMEN_COLLECTION_DATE) ~ \"\")) %>%\n      mutate(SEQUENCE_ROSTER_PREPARE_DATE = format(today(), \"%m/%d/%Y\")) %>%\n      mutate(SEQUENCE_EPI_ISL = \"\") %>%\n  unique() %>%\n  arrange(SEQUENCE_ACCESSION) %>% \n  mutate(QA_MULTIPLE_MATCH = case_when(rowid %in% rowid[duplicated(rowid)] ~ 1)) %>%\n  rowwise() %>%\n    mutate(sum = sum(\n      c_across(QA_COLLECT_DATE:QA_MULTIPLE_MATCH),\n      na.rm = TRUE\n    )\n    )\n\nprint(fuzzy3 %>% \n    select(QA_COLLECT_DATE:QA_MULTIPLE_MATCH) %>%\n    colSums(na.rm = TRUE))\n\nprint_roster(fuzzy3, for_review = TRUE)\n\nprint_error_rows(fuzzy3)\n\nrows_printed <- rows_printed %>% append(unique(fuzzy3$rowid))\nprint(paste(length(rows_printed), \"of\", nrow(fuzz), \"rows have been printed\"))\n\n# remove matched records from table\nfuzzy_case_counts <- filter(fuzzy_case_counts, !rowid %in% fuzzy3$rowid)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Wrap-UP {.tabset}\n\n## Saved Rows\n\nAny records with rowid's not printed to other files are sent to the rows_not_yet_printed subfolder of the Fuzzy Matches submissions folder in the saved_rows file. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nold_saved_delete <- dir_ls(\"Submissions/Fuzzy_Match/rows_not_yet_printed\")\n\nfile_delete(old_saved_delete)\n\nfuzz_saved <- fuzz %>% filter(!(rowid %in% rows_printed))\n\nwrite_csv(fuzz_saved, paste0(\"Submissions//Fuzzy_Match//rows_not_yet_printed//saved_rows_\", today(), \".csv\"))\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Move Files\n\nInput files are moved to the Completed folder. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nfiles_to_move <-  dir_ls(paste0(\"Submissions/Fuzzy_Match\"), type = \"file\")\n\nnew_file_names <- paste0(\"Completed_Submissions/Fuzzy_Match/\", basename(files_to_move))\n\nfile_move(files_to_move, new_file_names)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Completed Email\n\nAlerts are compiled and an email is sent with details about the files produced by the script. \n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nall_fuzzy_files <- dir_ls(\"write_roster_here\") %>% str_subset(\"fuzzy\")\nall_fuzzy_files <- c(all_fuzzy_files, dir_ls(\"For_Review\") %>% str_subset(\"fuzzy\"))\nall_fuzzy_files <- c(all_fuzzy_files, dir_ls(\"For_Review/to_process_fuzzy_match\") %>% str_subset(\"fuzzy\"))\nall_fuzzy_files <- c(all_fuzzy_files, dir_ls(\"Fuzzy_matches\") %>% str_subset(\"fuzzy\"))\nall_fuzzy_files <-  c(all_fuzzy_files, dir_ls(\"Fuzzy_matches/Fuzzy_Error_Checks\") %>% str_subset(\"fuzzy\"))\nall_fuzzy_files <-  c(all_fuzzy_files, dir_ls(\"Fuzzy_matches\") %>% str_subset(\"did_not_match\"))\n\n\ntoday_fuzzy_files <- all_fuzzy_files[str_detect(all_fuzzy_files, as.character(today()))] %>% unique()\n\ntoday_fuzzy_review_files1 <- today_fuzzy_files %>% str_extract(\"For_Review.*\") %>% na.omit() %>% as.character()\ntoday_fuzzy_review_files2 <- today_fuzzy_files %>% str_extract(\"Fuzzy_matches.*\") %>% na.omit() %>% as.character()\ntoday_fuzzy_review_files <- c(today_fuzzy_review_files1, today_fuzzy_review_files2)\ntoday_fuzzy_roster_files <- today_fuzzy_files %>% str_extract(\"write_roster_here.*\") %>% na.omit() %>% as.character()\n\n# initialize message\nfuzzy_email_message <- paste(\"Fuzzy matched files were printed for COVID Sequencing data for\", format(today(), \"%m/%d/%Y\"), \n                                    \"and are ready for manual review. \\n\")\n\n\n\n# if there files that are ready to be added to the roster\nif (length(today_fuzzy_roster_files) > 0) {\n  today_fuzzy_roster_file_names <- paste(unlist(today_fuzzy_roster_files), collapse='\\n')\n  fuzzy_email_message <- paste0(fuzzy_email_message,\"\\n\\n\" , \"There were a total of \", length(today_fuzzy_roster_files), \" file(s) written today that contain records that could be exactly matched to records in WDRS and are ready to be added to the roster. These files can be found at: \", \"\\n\", today_fuzzy_roster_file_names)\n}\n\n# if there files that are ready to be added to the roster\nif (length(today_fuzzy_review_files) > 0) {\n    today_fuzzy_review_file_names <- paste(unlist(today_fuzzy_review_files), collapse='\\n')\n  fuzzy_email_message <- paste0(fuzzy_email_message,\"\\n\\n\" , \"There were a total of \", length(today_fuzzy_review_files), \" file(s) written today that require manual review. These files can be found at: \", \"\\n\", today_fuzzy_review_file_names)\n}\n\n\n# Finalize message\nfuzzy_email_message <- paste0(fuzzy_email_message, \"\\n\\n\", \"Note: This is an automated message. Please enable your outlook to include extra line breaks to view this message in its proper format.\", \"\\n\\n\", \"This message is in development, and will be updated. If you see any errors reach out to DIQA. Thanks!\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# send email notifying that fuzzy matching has completed\n  sendmailR::sendmail(\n    from = \"\",\n    to = c(\n      \"\"\n    ),\n    subject = \"Sequencing - COVID Sequencing Fuzzy Match script complete\",\n    msg = fuzzy_email_message,\n    headers = list(\"Reply-To\" = \"\"),\n    control = list(smtpServer = \"\")\n  )\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# Update fuzzy for review running list\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# read in running file\nrunning_list <- read_csv(\"For_Review/running_lists/fuzzy_for_review_records.csv\", col_types = cols(.default = \"c\") )\n\n# Read in any fuzzy perfect/fuzzy1/fuzzy2/fuzzy3 error row files from today\nfuzzy_review_files <- dir_ls(\"For_Review\", type=\"file\") %>% str_subset(\"fuzzy\")\n\n# only today\nfuzzy_review_files <- fuzzy_review_files[str_detect(fuzzy_review_files, as.character(today()))] %>% unique()\n\n# Create empty dataframe\nfuzzy_other_review <- data.frame()\n\nif(length(fuzzy_review_files) > 0) {\n  \nfor (i in 1:length(fuzzy_review_files)){\n  \ntemp_data <- read_csv(fuzzy_review_files[i], col_types = cols(.default = \"c\"))\ntemp_data<-temp_data %>%\nmutate(File_PATH=fuzzy_review_files[i])\nfuzzy_other_review <- bind_rows(fuzzy_other_review, temp_data)\n}\n}\n\nfuzz_bad_rows <- fuzz_bad_rows %>% mutate(across(everything(), as.character))\ndid_not_match <- did_not_match %>% mutate(across(everything(), as.character))\n\n# Combine all records\nrunning_list_updated <-bind_rows(fuzzy_other_review, fuzz_bad_rows, did_not_match, running_list)\n\n# Make sure sequence accession is filled out\nrunning_list_updated <- running_list_updated %>% mutate(SEQUENCE_ACCESSION = case_when(is.na(SEQUENCE_ACCESSION) ~ GISAID_ID, \n                                                                                      (!(is.na(SEQUENCE_ACCESSION)) ~SEQUENCE_ACCESSION)))\n# Flag records now in WDRS\nrunning_list_updated <- running_list_updated %>% mutate(WDRS_complete = ifelse(SEQUENCE_ACCESSION %in% wdrs_sa_flat_values, \"1\", \"0\"))%>%distinct(SEQUENCE_ACCESSION, .keep_all = TRUE)\n\nwdrs_complete <- running_list_updated %>% filter(WDRS_complete==1)%>%distinct(SEQUENCE_ACCESSION)\nmanual_review_total <- running_list_updated %>% filter(WDRS_complete==0)%>%distinct(SEQUENCE_ACCESSION)\n\n# Write updated list\nwrite.csv(running_list_updated, file.path(paste0(\"For_Review/running_lists/fuzzy_for_review_records.csv\")), na=\"\",row.names = FALSE)\n\n\n# Send email with review results\n\n  email_from <- \"\"\n  email_to <- \"\"\n  email_subj <- \"Sequencing - Fuzzy For Review Summary Automated Email\"\n  \n  email_body <- paste(\n  \"Overview: \\n \\n\",\n  (nrow(manual_review_total)), \"records pending manual review or roster. \\n\",\n  (nrow(wdrs_complete)), \"records completed to date.\\n\"\n  \n  )\n\n# send it\nsendmailR::sendmail(from = email_from,\n                    to = email_to,\n                    subject = email_subj,\n                    msg = email_body,\n                    headers= list(\"Reply-To\" = email_from),\n                    control = list(smtpServer = \"\"))\n```\n:::\n",
    "supporting": [
      "FUZZY_MATCHING_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}