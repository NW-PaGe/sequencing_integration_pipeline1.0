---
title: "QA_for_review"
author: "DIQA"
date: "`r Sys.Date()`"
output: html_document
---

# This script reviews sequencing records sent to For_Review because of 12 possible quality issues
# If a programmatic solution is possible, records are fixed and sent to write roster here
# Records without a programmatic solution will be sent to manual review, supported by Data Support/DIQA

# Frank - we may not need this TBD
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source_rmd <- function(file, local = FALSE, ...){
  options(knitr.duplicate.label = 'allow')

  tempR <- tempfile(tmpdir = ".", fileext = ".R")
  on.exit(unlink(tempR))
  knitr::purl(file, output=tempR, quiet = TRUE)

  envir <- globalenv()
  source(tempR, local = envir, ...)
}
```

# Load Libraries
```{r}
library(DBI)
library(odbc)
library(lubridate)
library(tidyverse)
library(fs)
library(fuzzyjoin)
library(here)
library(sendmailR)
library(readxl)
library(data.table)
library(purrr)
library(vroom)
```

# Read in files for review
```{r}
# read in r_creds.RDS
r_creds <-readRDS(file.path(Sys.getenv("USERPROFILE"), "Projects/Sequencing/Data_Objects", "r_creds.RDS"))

# Will only list the csv files, not the xlsx template file
filenames <- list.files("", full.names=TRUE, pattern="*.csv")

# Create empty dataframe
submissions_template <- data.frame()

for (i in 1:length(filenames)){
  
temp_data <- read.csv(filenames[i], colClasses = c("SEQUENCE_CLINICAL_ACCESSION"="character"))
temp_data<-temp_data %>%
mutate(File_PATH=filenames[i])
submissions_template <- bind_rows(submissions_template, temp_data)
}

```

# Set up WDRS connection requirements
```{r}
# connect
connection <- DBI::dbConnect(odbc::odbc(), 
                             Driver = r_creds$conn_list[1], 
                             Server = r_creds$conn_list[2], 
                             Database = r_creds$conn_list[3], 
                             Trusted_connection = r_creds$conn_list[4], 
                             ApplicationIntent = r_creds$conn_list[5])
```

# If theres no new file send an email stating so and stop the script. If there are new files, script will continue
```{r}
# check if there are any files that require review. If there are no new files, send an email stating so.
if (length(submissions_template) == 0) {
  email_from <- ""
  email_to <- ""
  email_subj <- "Sequencing - For_Review: No New Submissions"
  email_body <- "No new records have been output for review. Script has been stopped and rendered up to this point."

# send it
sendmailR::sendmail(from = email_from,
                    to = email_to,
                    subject = email_subj,
                    msg = email_body,
                    headers= list("Reply-To" = email_from),
                    control = list(smtpServer = ""))

print("No new records have been output for review. Script has been stopped and rendered up to this point.")
}

# exit run/render of script if there are no files. When this rmd is ran from a trigger script which uses render() the script will stop here and only render up to this point via knit_exit(). When this rmd is ran manually the script will stop here via stop()
if (length(submissions_template) == 0) {
  knit_exit()
  stop()
}

```

# Move files into archive folder with todays date
```{r}

if(length(filenames > 0)){

  # Create folder in Archive
  dir_create(paste0(file.path(""), today()))
   
  # Move files to archive
  file_move(filenames, paste0(file.path(""), today()))
}

```

# Load WA GISAID data
```{r}
wa_gisaid <- read_rds("")
```

# Query COVID19 FLATTENED table for sequencing fields of interest
```{r}
# pull all vars of interest below from the [DD_GCD_COVID_19_FLATTENED] table where CDC_N_COV_2019_SEQUENCE_SPECIMEN was entered as 'Yes' (these are specimens that have been sequenced and rostered).
wdrs_flat <- dbGetQuery(connection, "
  SELECT CASE_ID,
    CDC_N_COV_2019_SEQUENCE_SPECIMEN,
    CDC_N_COV_2019_SEQUENCE_REASON,
    CDC_N_COV_2019_SEQUENCE_LAB,
    CDC_N_COV_2019_SEQUENCE_STATUS,
    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,
    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT,
    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,
    CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE,
    CDC_N_COV_2019_SEQUENCE_NOTES,
    STATUS, 
    CREATE_DATE
  FROM [dbo].[DD_GCD_COVID_19_FLATTENED]
  WHERE CDC_N_COV_2019_SEQUENCE_SPECIMEN LIKE '%Yes%'
")

# separate comma separated values, rename, and trim whitespace. Filter to records where CDC_N_COV_2019_SEQUENCE_SPECIMEN is not "No".
wdrs_flat_clean <- wdrs_flat %>% 
 separate_rows(
    CDC_N_COV_2019_SEQUENCE_SPECIMEN,
    CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER,
    CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER,
    CDC_N_COV_2019_SEQUENCE_REASON,
    CDC_N_COV_2019_SEQUENCE_LAB,
    CDC_N_COV_2019_SEQUENCE_REASON,
    CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT ,
    CDC_N_COV_2019_SEQUENCE_STATUS,
    CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE,
    sep = ', ',
    convert = TRUE
  ) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_SPECIMEN = str_trim(CDC_N_COV_2019_SEQUENCE_SPECIMEN, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_REASON = str_trim(CDC_N_COV_2019_SEQUENCE_REASON, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_LAB = str_trim(CDC_N_COV_2019_SEQUENCE_LAB, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_STATUS = str_trim(CDC_N_COV_2019_SEQUENCE_STATUS, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER = str_trim(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT = str_trim(CDC_N_COV_2019_SEQUENCE_VARIANT_OPEN_TEXT, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER = str_trim(CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_NOTES = str_trim(CDC_N_COV_2019_SEQUENCE_NOTES, side = "both")) %>%
  mutate(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE = str_trim(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE, side = "both"))%>%
  #date needs to be in correct format
  mutate(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE = as.Date(CDC_N_COV_2019_SEQUENCE_SPECIMEN_COLLECTION_DATE,"%m/%d/%Y"))%>%
  # separate_rows creates blanks as "" and not NA for the separated rows. Need to force them as NA
  mutate_at(vars(-("CREATE_DATE")),~na_if(.,""))%>%
  filter(tolower(CDC_N_COV_2019_SEQUENCE_SPECIMEN) == "yes")
```

# Query ELR Entire table for lab filler order number and specimen collection date
```{r}
wdrs_ent <- dbGetQuery(
connection,
"
SELECT Distinct CASE_ID,
[FILLER__ORDER__NUM] as SEQUENCE_CLINICAL,
SPECIMEN__COLLECTION__DTTM as COLLECTION_DATE
FROM [dbo].[DD_ELR_DD_ENTIRE]
WHERE CODE = 'SARS'
"
)
```

# Count the number of flags across a row for the QA flag column
# Need count_yes column to determine single error vs multiple error records
# Will range from 1 to 12, but usually 1-3
```{r}
# Count the number of flags across a row for the QA flag columns
for_review <- submissions_template %>%
  mutate(count_yes = rowSums(across(contains("QA_"), `%in%`, 1)))
```

# General deduplication step
# Some records are accidently processed more than once and appear in multiple for_review files with a different date in sequence note
# This happens infrequently 
```{r}
# Dedup on important variables but not sequence note
# This is only relevant when the same submissions are processed multiple times
for_review <- distinct(for_review, CASE_ID, SEQUENCE_SPECIMEN, SEQUENCE_LAB, SEQUENCE_STATUS, SEQUENCE_REPOSITORY,   
                       SEQUENCE_ACCESSION,SEQUENCE_VARIANT_OPEN_TEXT, SEQUENCE_CLINICAL_ACCESSION, SEQUENCE_SPECIMEN_COLLECTION_DATE, .keep_all=TRUE)
```

# Check if Sequence Accession is in WDRS (note this is the same as QA_SA_WDRS_DUPE but double checks the other SAs)
# This is probably another redundant step but provides extra reassurance if records have been sitting for a long time
```{r}
# Check if SA is already in WDRS
sa_wdrs_check <- wdrs_flat_clean %>% 
  filter(! is.na(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)) %>%
  filter(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER !="") %>%
  inner_join(for_review, by=c("CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER" = "SEQUENCE_ACCESSION")) %>% 
  select(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)

# If the Sequence Accession is in WDRS, then we can ignore the record even if the lineage is different
# Molecular Epi has a process to look for significantly different changes in lineage, we do not need to keep track of these re submissions
# If the sequence accession is in WDRS, flag as "remove"

# Create remove flag
for_review <- for_review %>% mutate(remove = ifelse(SEQUENCE_ACCESSION %in% sa_wdrs_check$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER, "1", "0"))
        
```

# Separate duplicates from non duplicate issues
# If a duplicate still has other quality issues it will be combined back with for_review_other later
```{r}
# Keep only duplicates
for_review_duplicates <- for_review %>% filter(!(is.na(QA_SA_INT_DUPE) & is.na(QA_SCA_INT_DUPE) & is.na(QA_SA_WDRS_DUPE) & is.na(QA_SCA_WDRS_DUPE)))

# Keep all non duplicates
for_review_other <- for_review %>% filter((is.na(QA_SA_INT_DUPE) & is.na(QA_SCA_INT_DUPE) & is.na(QA_SA_WDRS_DUPE) & is.na(QA_SCA_WDRS_DUPE)))

# Check that no records were lost
if ((nrow(for_review_duplicates)+nrow(for_review_other)) != (nrow(for_review))) {
   print("Not all for review records accounted for - whats up?")
   } else{
   print("All for review records accounted for!")
   }

```
# INTERNAL DUPLICATES
# Separate for_review flags - QA_SCA_INT_DUPE only, QA_SA_INT_DUPE only, or BOTH SCA/SA INT DUPE
# These are handled differently given the duplicate type
```{r}
# SCA is duplicated internally only
sca_int_dupe <- for_review_duplicates %>% filter(QA_SCA_INT_DUPE==1 & is.na(QA_SA_INT_DUPE))

# SA duplicated internally only
sa_int_dupe <- for_review_duplicates %>% filter(QA_SA_INT_DUPE==1 & is.na(QA_SCA_INT_DUPE))

# SCA and SA both duplicated internally
sca_sa_int_dupe <- for_review_duplicates %>% filter(QA_SCA_INT_DUPE==1 & QA_SA_INT_DUPE==1)

```

# If SCA and SA are both duplicated internally, the two records likely match to two different case_ids
# Sometimes, one of the case_ids is clearly an incorrect match and is also marked as "QA_COLLECT_DATE"
# We can remove the bad match if it is also marked as QA_COLLECT_DATE
# Otherwise, flag as for manual review
```{r}

`%notin%` <- Negate(`%in%`)

# Filter for those SA/SCA pairs with a bad match based on collection date
sca_sa_int_collection_date <- sca_sa_int_dupe %>% group_by(SEQUENCE_ACCESSION, SEQUENCE_CLINICAL_ACCESSION, QA_COLLECT_DATE) %>% 
                              filter(n()==1) %>% 
                              mutate(remove = case_when((QA_COLLECT_DATE ==1) ~ 1, 
                                              (is.na(QA_COLLECT_DATE)) ~ 0)) %>% 
                              mutate(manual_review = case_when((QA_COLLECT_DATE==1) ~ 0, 
                                              (is.na(QA_COLLECT_DATE)) ~ 0))

# Filter for those SA/SCA pairs that match to one/the same case_id - this doesn't seem to happen frequently
sca_sa_int_same_case <- sca_sa_int_dupe %>% group_by(CASE_ID, SEQUENCE_ACCESSION, SEQUENCE_CLINICAL_ACCESSION) %>% filter(n()>1) %>% mutate(remove=0, manual_review =1) 

# Filter for those records that match to multiple/different case_ids regardless of collection date - send these to manual review
sca_sa_int_diff_case <- sca_sa_int_dupe %>% filter(CASE_ID %notin% sca_sa_int_collection_date$CASE_ID) %>% 
                        filter(CASE_ID %notin% sca_sa_int_same_case$CASE_ID) %>% mutate(remove =0, manual_review=1)


# Combine back into one dataframe 
sca_sa_int_dupe_reviewed <- rbind(sca_sa_int_diff_case, sca_sa_int_collection_date, sca_sa_int_same_case)

# Check that no records were lost
if (nrow(sca_sa_int_dupe) != (nrow(sca_sa_int_dupe_reviewed))) {
   print("Not all records are accounted for - locate missing records")
   } else{
   print("All SCA/SA internal duplicates reviewed and accounted for!")
   }

```

# SCA repeated internally only
# If only SCA is repeated internally, we can roster the record IF the case_ids are the same (SA must be different)
# Note: This is different from SCA WDRS DUPE 
# If SCA repeated internally with two different case_ids its bc the person has two case_ids and must go to manual review to determine correct match
```{r}

# Group by SCA and CASE_ID - matches to the same case_id so good
same_sca_good <- sca_int_dupe %>% 
  group_by(CASE_ID, SEQUENCE_CLINICAL_ACCESSION) %>% 
  filter(n()>1) %>% mutate(remove =0, manual_review=0)

# Group by SCA and CASE_ID - matches to distinct case_ids so bad
same_sca_bad <- sca_int_dupe %>% 
  group_by(CASE_ID, SEQUENCE_CLINICAL_ACCESSION) %>% 
  filter(n()==1) %>% mutate(remove =0, manual_review=1)

# Combine back into one dataframe 
sca_int_dupe_reviewed <- rbind(same_sca_good, same_sca_bad)

```

# SA repeated internally only, SA is not in WDRS
# Often matches to two case_ids and therefore requires manual review
```{r}
# Flag these for manual review
sa_int_dupe_reviewed <- sa_int_dupe %>% mutate(remove =0, manual_review=1)
```

# Combine all the internal duplicates
```{r}
internal_duplicates_reviewed <- rbind(sca_sa_int_dupe_reviewed, sca_int_dupe_reviewed, sa_int_dupe_reviewed)
```

# WDRS DUPLICATES
# Separate for_review flags - QA_SCA_WDRS_DUPE only, QA_SA_WDRS_DUPE only, or BOTH SCA/SA WDRS DUPE
# These are handled differently given the duplicate type
```{r}
# SCA is duplicated with WDRS only
sca_wdrs_dupe <- for_review %>% filter(QA_SCA_WDRS_DUPE==1 & is.na(QA_SA_WDRS_DUPE))

# SA duplicated with WDRS only
sa_wdrs_dupe <- for_review %>% filter(QA_SA_WDRS_DUPE==1 & is.na(QA_SCA_WDRS_DUPE))

# SCA and SA both duplicated with WDRS
sca_sa_wdrs_dupe <- for_review %>% filter(QA_SCA_WDRS_DUPE==1 & QA_SA_WDRS_DUPE==1)

```

# SA WDRS duplicates only can be ignored
```{r}
sa_wdrs_dupe_reviewed <- sa_wdrs_dupe %>% mutate(remove =1, manual_review=0) 
```

# If SA and SCA are both duplicated with WDRS, they can be ignored as well
```{r}
sca_sa_wdrs_dupe_reviewed <- sca_sa_wdrs_dupe %>% mutate(remove =1, manual_review=0) 
```

# SCA repeated with WDRS only
# If only SCA is repeated with WDRS, we can roster the record IF the case_ids are the same (SA must be different)
```{r}
# Because SA is not in WDRS, we do not need to worry about creating a duplicate, we just need to make sure the case_ids are the same

# Find case_id associated with the SCA in WDRS
sca_wdrs_check <- wdrs_flat_clean %>% 
  filter(! is.na(CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER)) %>%
  filter(CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER !="") %>%
  inner_join(sca_wdrs_dupe, by=c("CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER" = "SEQUENCE_CLINICAL_ACCESSION")) %>% 
  select(CASE_ID.x, CASE_ID.y, CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER, CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER, SEQUENCE_ACCESSION)
 
# Just for this check change NA SA to blank so it can be compared
sca_wdrs_check$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER[is.na(sca_wdrs_check$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)] <- ""      

# We want SA to be different within case id but they do not need to be compared between case_ids
sca_wdrs_check <-sca_wdrs_check %>% filter(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER!=SEQUENCE_ACCESSION) 

# Keep the SCAs that match to the same case_id and have different sequence accessions
sca_wdrs_dupe_good <- sca_wdrs_dupe %>%
                    filter(SEQUENCE_CLINICAL_ACCESSION %in% sca_wdrs_check$CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER) %>%
                    mutate(remove =0, manual_review=0)

sca_wdrs_dupe_bad <- sca_wdrs_dupe %>%
                filter(SEQUENCE_CLINICAL_ACCESSION %notin% sca_wdrs_check$CDC_N_COV_2019_SEQUENCE_CLINICAL_ACCESSION_NUMBER) %>%                     
                  mutate(remove=0, manual_review=1)

sca_wdrs_dupe_reviewed <- rbind(sca_wdrs_dupe_good, sca_wdrs_dupe_bad)

```

# Combine all the WDRS duplicates
```{r}
wdrs_duplicates_reviewed <- rbind(sca_wdrs_dupe_reviewed, sca_sa_wdrs_dupe_reviewed, sa_wdrs_dupe_reviewed)
```

# Combine back together internal and wdrs duplicates
```{r}
duplicates_reviewed <- rbind(wdrs_duplicates_reviewed, internal_duplicates_reviewed)

# Check that no records were lost
if (nrow(duplicates_reviewed) != (nrow(for_review_duplicates))) {
   print("Not all duplicate records are accounted for - locate missing records :(")
   } else{
   print("All internal and WDRS duplicates reviewed!")
   }

```
# Separate duplicates out by result type - roster_prelim, manual review, or remove
```{r}
remove <- duplicates_reviewed %>% filter(remove==1)

manual_review <- duplicates_reviewed %>% filter(manual_review==1)

roster_prelim <- duplicates_reviewed %>% filter(remove==0 & manual_review==0)

# Change QA duplicate columns blank and recalculate count_yes
# If record still needs review for other non-duplicate reasons, it will be combined with for_review_other
roster_prelim <- roster_prelim %>% mutate_at(vars(c("QA_SCA_INT_DUPE", "QA_SA_INT_DUPE", "QA_SCA_WDRS_DUPE", "QA_SA_WDRS_DUPE")), ~na_if(., 1))

# Count the number of flags across a row for the QA flag column
roster_prelim <- roster_prelim %>%
  mutate(count_yes = rowSums(across(contains("QA_"), `%in%`, 1)))
```

# If a record still has other quality issues, combine with for_review_other
```{r}
# If count_yes >0 then there are other quality issues present and must be sent through rest of script
roster_quality_issues <- roster_prelim %>% filter(count_yes>0)

if (nrow(roster_quality_issues>0)) {
   print("Some duplicate records still have quality issues, combining with for_review_other")
  
  roster_quality_issues$remove <- as.character(roster_quality_issues$remove)
  for_review_other <-bind_rows(for_review_other, roster_quality_issues)
 
   } else{
   print("No duplicates with other quality issues")
   }

```

# Prepare duplicates roster and output to write_roster_here
```{r}
# If count_yes==0 then record has no other quality issues and can be rostered!
roster_final_duplicates <- roster_prelim %>% filter(remove==0 & manual_review==0 & count_yes==0)

roster_final_duplicates <- roster_final_duplicates %>% select (
          "CASE_ID",
          "SEQUENCE_SGTF",
          "SEQUENCE_SPECIMEN",
          "SEQUENCE_DATE",
          "SEQUENCE_REASON",
          "SEQUENCE_LAB",
          "SEQUENCE_STATUS",
          "SEQUENCE_REPOSITORY",
          "SEQUENCE_ACCESSION",
          #"SEQUENCE_EPI_ISL",
          "SEQUENCE_VARIANT_OPEN_TEXT",
          "SEQUENCE_CLINICAL_ACCESSION", 
          "SEQUENCE_SPECIMEN_COLLECTION_DATE",
          #"SEQUENCE_ROSTER_PREPARE_DATE",
          "SEQUENCE_NOTES",
          "SEQUENCE_REVIEWED",
          "Case.Note")


if (nrow(roster_final_duplicates>0)) {
   print("Duplicate Records sent to write_roster_here")
  
   write.csv(roster_final_duplicates, file.path(paste0("",today(),".csv")), na="",row.names = FALSE)

   } else{
   print("No duplicate records for roster today")
   }

```


# Output duplicate records that require manual review from DIQA/Data Support
```{r}
# Write records with manual review issues to folder for DIQA/Data Support review

if (nrow(manual_review>0)) {
   print("Duplicate records sent to manual review")
  
  # Commenting this out until we have a real location for Data Support - this was just a test folder
  #write.csv(manual_review, file.path(paste0("For_Review/DIQA Test/duplicates_manual_review_",today(),".csv")), na="",row.names = FALSE)

  # create a copy for DIQA
  write.csv(manual_review, file.path(paste0("",today(),".csv")), na="",row.names = FALSE)

   } else{
   print("No duplicate records for manual review today")
   }

```


# ####################################################################
#                 Continue with for_review_other                     #      
# ####################################################################

# Deal with Single Errors
## Create a new dataframe based on error - then we can feed each error through it's appropriate script
```{r}
single_error <- for_review_other %>% filter(remove==0) %>%
  filter(count_yes == 1)
```


# Use if statements to identify flags and then make programmatic changes. If a manual review is needed it will show up in the single_error_manual_review dataframe at the end of the script.

# QA_CASE_ID

CASE_ID is NA, meaning no match in WDRS, should be sent to fuzzy matching 

-     Programmatic
      +     Re-route record to keep_na? 
```{r}
if(any(!is.na(single_error$QA_CASE_ID))){
   # CASE_ID is NA, meaning no match in WDRS, should be sent to fuzzy matching 
   # Programmatic  
   # Re-route record to keep_na? 
   
}
```


# QA_SCA_NA

SEQUENCE_CLINICAL_ACCESSION is NA (Applies only to records from PHL or Template Submitter)

-     Manual
      +     Reach out to submitter after verifying an SCA was not populated in the original submissions. 
```{r}
if(any(!is.na(single_error$QA_SCA_NA))){
   # QA_SCA_NA: SEQUENCE_CLINICAL_ACCESSION is NA (Applies only to records from PHL or Template Submitter) 
   # Manual 
   # Reach out to submitter after verifying an SCA was not populated in the original submissions. 
   
   # Some Quest records are being flagged as SCA NA but that is allowed. Temp fix?
   quest_fix <- single_error %>% filter(QA_SCA_NA == 1) %>% filter(SEQUENCE_LAB=="Quest") %>%mutate_at(vars("QA_SCA_NA"), ~na_if(., 1))

   other_SCA_NA <- single_error %>% filter(QA_SCA_NA == 1) %>% filter(SEQUENCE_LAB!="Quest")
   
   qa_sca_na_single_error <- rbind(quest_fix, other_SCA_NA)
      
}
```


# QA_SEQ_VARIANT
```{r}
if(any(!is.na(single_error$QA_SEQ_VARIANT))){
   
   temp_qa_seq_variant_single_error <- single_error %>%
      filter(QA_SEQ_VARIANT == 1)
   
   wdrs_flat_clean$SEQUENCE_ACCESSION <- wdrs_flat_clean$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER
   
   matchfinal2<-anti_join(temp_qa_seq_variant_single_error, wdrs_flat_clean, by="SEQUENCE_ACCESSION")
   
   FoundLineage <-
      left_join(matchfinal2, wa_gisaid, by = c("SEQUENCE_ACCESSION" = 'virus_name_clean')) %>% 
      filter(!is.na(Lineage)) %>%
      mutate(SEQUENCE_STATUS = if_else(Lineage == "Unassigned", "LOW QUALITY", SEQUENCE_STATUS)) %>%
      mutate(SEQUENCE_VARIANT_OPEN_TEXT = Lineage)
   
   # voc <- readRDS(paste0(project_folder,"/Data_Objects/VOC/voc.RDS"))
   Roster <- FoundLineage %>%
      # mutate(SEQUENCE_VARIANT_OPEN_TEXT = case_when(SEQUENCE_VARIANT_OPEN_TEXT %in% voc ~ SEQUENCE_VARIANT_OPEN_TEXT,
      #                                     TRUE ~ "")) %>%
      mutate(SEQUENCE_NOTES = ifelse(SEQUENCE_ACCESSION == "", "", (
         paste0(
            "Lineage identified as ",
            Lineage,
            " on ",
            today(),
            ". Lineage assignments may change over time."
         )
      ))) %>%
      select(-Lineage)
   
   CDC_Cumulative <-
      read.csv(paste0(""))
   
   
   # dedup records
   CDC_Cumulative <- distinct(CDC_Cumulative)
   wadata2 <- distinct(wa_gisaid)
   
   CDC <- CDC_Cumulative %>%
      anti_join(wadata2, by = c("GISAID_name" = "Virus name"))
   
   Prep_CDC <- CDC %>%
      mutate(SEQUENCE_ACCESSION = str_match(GISAID_name, "hCoV-19/(.*$)")[, 2]) %>%
      select(SEQUENCE_ACCESSION, lineage_PANGO_lineage)
   
   
   FoundLineageCDC <-
      left_join(matchfinal2, Prep_CDC, by = ("SEQUENCE_ACCESSION")) %>%
      filter(!is.na(lineage_PANGO_lineage)) %>%
      mutate(SEQUENCE_STATUS = if_else(lineage_PANGO_lineage == "None", "LOW QUALITY", SEQUENCE_STATUS)) %>%
      mutate(SEQUENCE_VARIANT_OPEN_TEXT = lineage_PANGO_lineage)
   
   if(nrow(FoundLineage)!= 0 & nrow(FoundLineageCDC)!=0){
      #need to match number of columns (or add the by statement)
      FoundLineage2 <- Roster %>%
         select(
            CASE_ID,
            SEQUENCE_SGTF,
            SEQUENCE_SPECIMEN,
            SEQUENCE_REASON,
            SEQUENCE_DATE,
            SEQUENCE_LAB,
            SEQUENCE_STATUS,
            SEQUENCE_REPOSITORY,
            SEQUENCE_ACCESSION,
            SEQUENCE_VARIANT_OPEN_TEXT,
            SEQUENCE_CLINICAL_ACCESSION,
            SEQUENCE_SPECIMEN_COLLECTION_DATE,
            SEQUENCE_NOTES,
            SEQUENCE_REVIEWED,
            Case.Note,
            count_yes
         )
   } else if(nrow(FoundLineage) != 0 & nrow(FoundLineageCDC)==0){
      FoundLineage2 <- FoundLineage %>%
         select(
            CASE_ID,
            SEQUENCE_SGTF,
            SEQUENCE_SPECIMEN,
            SEQUENCE_REASON,
            SEQUENCE_DATE,
            SEQUENCE_LAB,
            SEQUENCE_STATUS,
            SEQUENCE_REPOSITORY,
            SEQUENCE_ACCESSION,
            SEQUENCE_VARIANT_OPEN_TEXT,
            SEQUENCE_CLINICAL_ACCESSION,
            SEQUENCE_SPECIMEN_COLLECTION_DATE,
            SEQUENCE_NOTES,
            SEQUENCE_REVIEWED,
            Case.Note,
            count_yes
         )
   } else if(nrow(FoundLineage)==0 & nrow(FoundLineageCDC!=0)){
      FoundLineage2 <- FoundLineageCDC %>%
         select(
            CASE_ID,
            SEQUENCE_SGTF,
            SEQUENCE_SPECIMEN,
            SEQUENCE_REASON,
            SEQUENCE_DATE,
            SEQUENCE_LAB,
            SEQUENCE_STATUS,
            SEQUENCE_REPOSITORY,
            SEQUENCE_ACCESSION,
            SEQUENCE_VARIANT_OPEN_TEXT,
            SEQUENCE_CLINICAL_ACCESSION,
            SEQUENCE_SPECIMEN_COLLECTION_DATE,
            SEQUENCE_NOTES,
            SEQUENCE_REVIEWED,
            Case.Note,
            count_yes
         )
   }
   
   FoundLineage3 <- FoundLineage2 %>%
      mutate(
         SEQUENCE_STATUS = toupper(SEQUENCE_STATUS),
         SEQUENCE_NOTES = if_else(
            is.na(SEQUENCE_NOTES) &
               SEQUENCE_VARIANT_OPEN_TEXT != "",
            paste0(
               "Lineage identified as ",
               SEQUENCE_VARIANT_OPEN_TEXT,
               " on ",
               Sys.Date(),
               ". Lineage assignments may change over time"
            ),
            SEQUENCE_NOTES
         )
      ) %>%
      mutate(SEQUENCE_VARIANT_OPEN_TEXT = if_else(
         SEQUENCE_VARIANT_OPEN_TEXT != "" &
            !is.na(SEQUENCE_VARIANT_OPEN_TEXT),
         SEQUENCE_VARIANT_OPEN_TEXT,
         NULL
      ))%>%
      mutate(SEQUENCE_NOTES = if_else(
         SEQUENCE_STATUS=="COMPLETE",SEQUENCE_NOTES,NULL
      ))
   
   FoundLineage4 <- FoundLineage3 %>%
      mutate(SEQUENCE_NOTES = if_else(!is.na(SEQUENCE_VARIANT_OPEN_TEXT), SEQUENCE_NOTES, NULL))
   
   subsetmissingCaseID <- FoundLineage4 %>%
      filter(is.na(CASE_ID))
   
   FoundLineage5 <- FoundLineage4 %>%
      filter(!is.na(CASE_ID)) %>%
      mutate(
         SEQUENCE_REASON = if_else(
            SEQUENCE_REASON == "PHL DIAGNOSTIC",
            "SENTINEL SURVEILLANCE",
            SEQUENCE_REASON
         )
      )
   
   # SEQUENCE_NOTES = {if("SEQUENCE_NOTES" %in% names(.)) cyl else NULL})%>%
   FoundLineageFinal <- FoundLineage5 %>% as_tibble() %>%
      mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = format(mdy(SEQUENCE_SPECIMEN_COLLECTION_DATE), "%m/%d/%Y")) %>%
      unique()
   
   # Clean up BA.2.12.1 Marker Override issue
   FoundLineageFinal <- FoundLineageFinal %>% 
         mutate(SEQUENCE_VARIANT_OPEN_TEXT = if_else(
         SEQUENCE_VARIANT_OPEN_TEXT == "BA.2.12.1 (marker override: BA.2.12 + Spike_L452Q => BA.2.12.1)", 
         "BA.2.12.1",
         SEQUENCE_VARIANT_OPEN_TEXT)) %>% 
         
      mutate(SEQUENCE_NOTES = if_else(
               SEQUENCE_VARIANT_OPEN_TEXT == "BA.2.12.1",
            paste0(
               "Lineage identified as ",
               SEQUENCE_VARIANT_OPEN_TEXT,
               " on ",
               Sys.Date(),
               ". Lineage assignments may change over time"
            ),
            SEQUENCE_NOTES
         ))
   
   qa_seq_variant_single_error <- FoundLineageFinal
} 
```

# QA_SEQ_STAT

SEQUENCE_VARIANT_OPEN_TEXT is not in the list of valid lineages or is NA while SEQUENCE_STATUS is "COMPLETE" (which means the SEQUENCE_NOTES populated with the incorrect lineage also needs to be updated)

-     Programmatic 
      +     If SEQUENCE_STATUS is NA;  
      +     If SEQUENCE_ACCESSION is present populate as “COMPLETE”? 
      +     If SEQUENCE_ACCESSION is NOT present populate as “FAILED”? 
      
   -     If SEQUENCE_STATUS is ‘COMPLETE’ & SEQUENCE_ACCESSION is NA; 
      +     Transform SEQUENCE_STATUS to “FAILED”? 
   -     If SEQUENCE_STATUS is ‘FAILED’, ‘NOT DONE’, ‘HIGH CT’ & SEQUENCE_ACCESSION is not NA 
      +     Transform SEQUENCE_STATUS to “COMPLETE”? 
```{r}
if(any(!is.na(single_error$QA_SEQ_STAT))){
   
   temp_qa_seq_stat_single_error <- single_error %>%
      filter(QA_SEQ_STAT == 1) 
   
   # +     If SEQUENCE_STATUS is NA;  
   # +     If SEQUENCE_ACCESSION is present populate as “COMPLETE”? 
   # +     If SEQUENCE_ACCESSION is NOT present populate as “FAILED”?    
   temp_qa_seq_stat_single_error1 <- temp_qa_seq_stat_single_error %>%
         filter(is.na(SEQUENCE_STATUS)) %>%
         mutate(SEQUENCE_STATUS = case_when(
            !is.na(SEQUENCE_ACCESSION) ~ "COMPLETE",
            is.na(SEQUENCE_ACCESSION) ~ "FAILED"
         ))
   
    # -     If SEQUENCE_STATUS is ‘COMPLETE’ & SEQUENCE_ACCESSION is NA; 
    #  +     Transform SEQUENCE_STATUS to “FAILED”? 
   temp_qa_seq_stat_single_error2 <- temp_qa_seq_stat_single_error %>%
         filter(temp_qa_seq_stat_single_error$SEQUENCE_STATUS == "COMPLETE" & is.na(temp_qa_seq_stat_single_error$SEQUENCE_ACCESSION)) %>%
         mutate(SEQUENCE_STATUS = "FAILED")
   
   # -     If SEQUENCE_STATUS is ‘FAILED’, ‘NOT DONE’, ‘HIGH CT’ & SEQUENCE_ACCESSION is not NA 
   # +     Transform SEQUENCE_STATUS to “COMPLETE”? 
   temp_qa_seq_stat_single_error3 <- temp_qa_seq_stat_single_error %>%
         filter(temp_qa_seq_stat_single_error$SEQUENCE_STATUS %in% c("FAILED","NOT DONE","HIGH CT") & !is.na(temp_qa_seq_stat_single_error$SEQUENCE_ACCESSION)) %>%
         mutate(SEQUENCE_STATUS = "COMPLETE")
   
   # Combine the seq stat errors
   qa_seq_stat_single_error <- bind_rows(temp_qa_seq_stat_single_error1,temp_qa_seq_stat_single_error2,temp_qa_seq_stat_single_error3)
}
```

# QA_SEQ_REASON

SEQUENCE_REASON is not a valid reason (differs between labs)

-     Manual
      +     Confirm the invalid/missing value manually, reach out to submitters for records submitted with no SEQUENCE_REASON or invalid SEQUENCE_REASON. 
```{r}
if(any(!is.na(single_error$QA_SEQ_REASON))){
   # Confirm value manually then do we send this out to submitters? Or just fill it in ourselves?
   
}
```

# QA_SEQ_NOTES

SEQUENCE_STATUS is complete and there are no sequence notes or SEQUENCE_STATUS is something else (failed, not done, high ct, low quality) but there are sequence notes 

-     Programmatic
      +     If SEQUENCE_STATUS is “COMPLETE” but SEQUENCE_NOTES is blank; populate as “Lineage identified as [SEQUENCE_VARIANT_OPEN_TEXT] on [SEQUENCE_SPECIMEN_COLLECTION_DATE]. Lineage assignments may change over time.” 
      +     If SEQUENCE_STATUS is ‘FAILED’, ‘NOT DONE’, ‘HIGH CT’ but SEQUENCE_NOTES is populated; do not populate. 
```{r}

if(any(!is.na(single_error$QA_SEQ_NOTES))){
   
   temp_qa_seq_notes_single_error <- single_error %>%
      filter(QA_SEQ_NOTES == 1) %>%
      # QA_SEQ_NOTES: SEQUENCE_STATUS is complete and there are no sequence notes or SEQUENCE_STATUS is something else (failed, not done, high ct, low quality) but there are sequence notes 
      # Programmatic 
      # If SEQUENCE_STATUS is “COMPLETE” but SEQUENCE_NOTES is blank; populate as “Lineage identified as [SEQUENCE_VARIANT_OPEN_TEXT] on [SEQUENCE_SPECIMEN_COLLECTION_DATE]. Lineage assignments may change over time.” 
      # If SEQUENCE_STATUS is ‘FAILED’, ‘NOT DONE’, ‘HIGH CT’ but SEQUENCE_NOTES is populated; do not populate. 
      mutate(SEQUENCE_NOTES = case_when(
         SEQUENCE_STATUS == "COMPLETE" & is.na(SEQUENCE_NOTES) ~ paste0("Lineage identified as ", SEQUENCE_VARIANT_OPEN_TEXT," on ",Sys.Date(),". Lineage assignments may change over time"),
         SEQUENCE_STATUS %in% c("LOW QUALITY","FAILED","NOT DONE","HIGH CT") & !is.na(SEQUENCE_NOTES) ~ NA_character_
      )
      ) %>%
      mutate(QA_SEQ_NOTES = NA)
   
   qa_seq_notes_single_error <- temp_qa_seq_notes_single_error 
   
} 
```



# QA_COLLECT_DATE

Collection date mismatch, collection dates are > 14 days apart (Whether inclusive/exclusive. It should be how scripts are currently set up now)


# QA_OTHER
```{r}

if(any(!is.na(single_error$QA_OTHER))){
   
   is_date = function(x, format = NULL) {
      formatted = try(as.Date(x, format), silent = TRUE)
      is_date = as.character(formatted) == x & !is.na(formatted)  # valid and identical to input
      is_date[is.na(x)] = NA  # Insert NA for NA in x
      return(is_date)
   }
   
   temp_qa_other_single_error <- single_error %>% 
      filter(QA_OTHER == 1) %>%
      
      # Take out the ones with only manual fixes
      # filter()
      
      #-	Is SEQUENCE_SGTF blank? 
      #o	Programmatic
      #	Populate SEQUENCE_SGTF as “”.
      mutate(SEQUENCE_SGTF = if_else(SEQUENCE_SGTF== "" | is.na(SEQUENCE_SGTF),SEQUENCE_SGTF,NULL))%>%
      # -	Is SEQUENCE_SPECIMEN hardcoded to 'YES'? 
      #   o	Programmatic
      # 	Populate SEQUENCE_SPECIMEN as “YES”.
      mutate(SEQUENCE_SPECIMEN = if_else(SEQUENCE_SPECIMEN != "YES","YES",SEQUENCE_SPECIMEN)) %>%
      # -	Is SEQUENCE_DATE blank?
      #   o	Programmatic
      # 	Populate SEQUENCE_DATE as “” 
      mutate(SEQUENCE_DATE = if_else(is.na(SEQUENCE_DATE) | SEQUENCE_DATE == "",SEQUENCE_DATE,NULL)) %>%
      # -	Is SEQUENCE_LAB populated? And is it a valid value within lab_variables.rds
      # o	Manual
      # 	Will have to review the original submission and identify if it is a valid submitter and where it originated from. Potentially reach out to submitter for correction.     
      # mutate(SEQUENCE_LAB = if_else(is.na(SEQUENCE_LAB) | SEQUENCE_LAB == "" | !SEQUENCE_LAB %in% lab_vars$lab_names_wdrs,)) %>%
      mutate(SEQUENCE_LAB = if_else(!is.na(SEQUENCE_LAB),SEQUENCE_LAB,NULL)) %>%
      # -	Is SEQUENCE_REPOSITORY set to "GISAID"? 
      #   o	Programmatic
      # 	Populate SEQUENCE_REPOSITORY as “GISAID”.
      mutate(SEQUENCE_REPOSITORY = if_else(is.na(SEQUENCE_REPOSITORY) | SEQUENCE_REPOSITORY == "","GISAID",SEQUENCE_REPOSITORY)) %>%
      # -	Is SEQUENCE_REVIEWED blank?
      #   o	Programmatic
      # 	Populate SEQUENCE_REVIEWED as “”.
      mutate(SEQUENCE_REVIEWED = "") %>%
      
      # -	Is SEQUENCE_ACCESSION formatted as “USA/WA-ACCESSION_ID/YYYY”?
      #   o	Programmatic
      # 	Check if any parts of the string outside of the ACCESSION_ID is missing and if it is then include it so SEQUENCE_ACCESSION matches the format above.
      # mutate(SEQUENCE_ACCESSION = if_else(str_detect(SEQUENCE_ACCESSION,
      #     "USA/([:alpha:]{2})-([:alpha:]{1,3})(-[:alpha:]{1,3}-|-[:alpha:]{1,3}|-[:digit:]{1,3}-|)([[:digit:]]+)/([2]02[0-2])|USA/WA-Altius-ALTCOV-([[:alnum:]]+)/([2]02[0-2])|USA/[:alpha:]{2}-[:alpha:]{1,}-[:digit:]{1,3}-([[:digit:]]+)/([2]02[0-2])|USA/([:alpha:]{2})-[:alpha:]{1,4}-([[:digit:]]+)/([2]02[0-2])"),SEQUENCE_ACCESSION,))
      mutate(SEQUENCE_ACCESSION = case_when(str_detect(
         "USA/([:alpha:]{2})-([:alpha:]{1,3})(-[:alpha:]{1,3}-|-[:alpha:]{1,3}|-[:digit:]{1,3}-|)([[:digit:]]+)/([2]02[0-2])|USA/WA-Altius-ALTCOV-([[:alnum:]]+)/([2]02[0-2])|USA/[:alpha:]{2}-[:alpha:]{1,}-[:digit:]{1,3}-([[:digit:]]+)/([2]02[0-2])|USA/([:alpha:]{2})-[:alpha:]{1,4}-([[:digit:]]+)/([2]02[0-2])",SEQUENCE_ACCESSION) ~ SEQUENCE_ACCESSION,
         TRUE ~ "Invalid SEQUENCE_ACCESSION. Check original ID"
      )) %>%
      # -	Id SEQUENCE_SPECIMEN_COLLECTION_DATE formatted correctly? (MM/DD/YYYY)
      # o	Programmatic 
      # 	Attempt to transform the value in SEQUENCE_SPECIMEN_COLLECTION_DATE to valid MM/DD/YYYY format.
      # o	Manual
      # 	If the value in SEQUENCE_SPECIMEN_COLLECTION_DATE is not in any format that can be identified and transformed to a date, check the value from the original submission comparing to the value in the roster and attempt to troubleshoot. Potentially reach out to submitter for correction.
      # mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = if_else(
      #    is_date(SEQUENCE_SPECIMEN_COLLECTION_DATE,format = "%m/%d/%Y"),as.Date(SEQUENCE_SPECIMEN_COLLECTION_DATE),as.Date(mdy(SEQUENCE_SPECIMEN_COLLECTION_DATE),format = "%m/%d/%Y")
      # ))
      mutate(SEQUENCE_SPECIMEN_COLLECTION_DATE = if_else(!is.na(SEQUENCE_SPECIMEN_COLLECTION_DATE),SEQUENCE_SPECIMEN_COLLECTION_DATE,NULL))%>%
      # -	Is Case.Note "External data question package updated by COVID19 Sequencing Roster."?
      #   o	Programmatic
      # 	Populate Case.Note as "External data question package updated by COVID19 Sequencing Roster."
      mutate(Case.Note = "External data question package updated by COVID19 Sequencing Roster.") %>%
      filter(SEQUENCE_ACCESSION != "Invalid SEQUENCE_ACCESSION. Check original ID") %>%
      mutate(QA_OTHER = NA)
   
   qa_other_single_error <- temp_qa_other_single_error
} 
```



# Send cleaned data to write_roster_here
## First format and combine them all together
```{r}
# Step 1: need to check if a dataframe is blank or not. If there are no errors flagged then a dataframe will not be created
is.defined <- function(sym) {
   sym <- deparse(substitute(sym))
   env <- parent.frame()
   exists(sym, env)
}
# Step 2: Define columns in the empty dataframe - these are needed if there are no flags for a column
df <- tibble(
   CASE_ID = character(),
   SEQUENCE_SGTF = character(),
   SEQUENCE_SPECIMEN = character(),
   SEQUENCE_REASON = character(),
   SEQUENCE_DATE = character(),
   
   SEQUENCE_LAB = character(),
   SEQUENCE_STATUS = character(),
   SEQUENCE_REPOSITORY = character(),
   SEQUENCE_ACCESSION = character(),
   SEQUENCE_VARIANT_OPEN_TEXT = character(),
   SEQUENCE_CLINICAL_ACCESSION = character(),
   SEQUENCE_SPECIMEN_COLLECTION_DATE = character(),
   SEQUENCE_NOTES = character(),
   SEQUENCE_REVIEWED = character(),
   Case.Note = character(),
   count_yes = character()
)
# Step 3: make a list of all data potentially with NA or FAIL 
# as an example - QA_OTHER is missing, QA_COLLECT_DATE is FAIL, and QA_SEQ_VARIANT were all fixed programmatically in the variant script (so the column is NA)
# All of these will go into a list and the ones with data will be combined automatically
matched_single_errors <- list()
matched_single_errors[['QA_CASE_ID']] <- if(is.defined(qa_case_id_single_error)){qa_case_id_single_error}else{df}
matched_single_errors[['QA_SCA_NA']] <- if(is.defined(qa_sca_na_single_error)){qa_sca_na_single_error}else{df}
matched_single_errors[['QA_SEQ_VARIANT']] <- if(is.defined(qa_seq_variant_single_error)){qa_seq_variant_single_error}else{df}
matched_single_errors[['QA_SEQ_STAT']] <- if(is.defined(qa_seq_stat_single_error)){qa_seq_stat_single_error}else{df}
matched_single_errors[['QA_SEQ_REASON']] <- if(is.defined(qa_seq_reason_single_error)){qa_seq_reason_single_error}else{df}
matched_single_errors[['QA_SEQ_NOTES']] <- if(is.defined(qa_seq_notes_single_error)){qa_seq_notes_single_error}else{df}
matched_single_errors[['QA_COLLECT_DATE']] <- if(is.defined(qa_collect_date_single_error)){qa_collect_date_single_error}else{df}
matched_single_errors[['QA_OTHER']] <- if(is.defined(qa_other_single_error)){qa_other_single_error}else{df}



# Step 4: combine all the single_errors back to one dataframe
combine_single_errors<- Reduce(function(x, y) merge(x, y, all=TRUE), matched_single_errors)

```

## Send to write_roster_here
```{r}
# Select all relevant columns for write_roster_here
single_error_to_write_roster_here <- combine_single_errors %>%
   mutate(count_yes = rowSums(across(contains("QA_"), `%in%`, 1))) %>%
   filter(is.na(count_yes))%>%
   select(
      CASE_ID,
      SEQUENCE_SGTF,
      SEQUENCE_SPECIMEN,
      SEQUENCE_REASON,
      SEQUENCE_DATE,
      SEQUENCE_LAB,
      SEQUENCE_STATUS,
      SEQUENCE_REPOSITORY,
      SEQUENCE_ACCESSION,
      SEQUENCE_VARIANT_OPEN_TEXT,
      SEQUENCE_CLINICAL_ACCESSION,
      SEQUENCE_SPECIMEN_COLLECTION_DATE,
      SEQUENCE_NOTES,
      SEQUENCE_REVIEWED,
      Case.Note
   )
if(nrow(single_error_to_write_roster_here)!=0){
   fwrite(single_error_to_write_roster_here,
             paste0("",
                "/",
                "single_error_reviewed_",
                today(),
                ".csv"
              ))

   
} else{
   print("single_error_to_write_roster_here dataframe is empty")
}

# Add a check to see numbers of matched and unmatched. They need to match total number for single_error df

```

# Find the records that are left over and send them to manual review
```{r}
single_error_manual_review <- single_error %>% 
   mutate(CASE_ID=as.character(CASE_ID)) %>%
   anti_join(single_error_to_write_roster_here,by = "CASE_ID")

# Send single error manual review to data support
if(nrow(single_error_manual_review)!=0){
   
  # Output to data support folder - TBD Removing this for now 
  #write.csv(single_error_manual_review, file.path(paste0("For_Review/DIQA Test/single_error_manual_review_",today(),".csv")), na="",row.names = FALSE)

  # create a copy for DIQA
  write.csv(single_error_manual_review, file.path(paste0("",today(),".csv")), na="",row.names = FALSE)
   
} else{
   print("single_error_manual_review dataframe is empty")
}

```

# Multiple errors
```{r}
multiple_errors <- for_review_other %>%
  filter(count_yes > 1)

# Send multiple errors manual review to DIQA
if(nrow(multiple_errors)!=0){
   
  # create a copy for DIQA
  write.csv(multiple_errors, file.path(paste0("",today(),".csv")), na="",row.names = FALSE)
   
} else{
   print("multiple errors dataframe is emptyyy")
}
```
# Update for_review running list
```{r}
# read in file
running_list <- read_csv("", col_types = cols(.default = "c") )

# add new records to list - only want unique sequence accessions
new_records <- for_review %>% distinct(SEQUENCE_ACCESSION, .keep_all = TRUE) %>% mutate(across(everything(), as.character))

running_list_updated <- bind_rows(running_list, new_records)

# Check if old records made it into WDRS
sa_wdrs_check <- wdrs_flat_clean %>% 
  filter(! is.na(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)) %>%
  filter(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER !="") %>%
  inner_join(running_list_updated, by=c("CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER" = "SEQUENCE_ACCESSION")) %>% 
  select(CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER)

# Flag records now in WDRS
running_list_updated <- running_list_updated %>% mutate(WDRS_complete = ifelse(SEQUENCE_ACCESSION %in% sa_wdrs_check$CDC_N_COV_2019_SEQUENCE_ACCESSION_NUMBER, "1", "0"))%>% distinct(SEQUENCE_ACCESSION, .keep_all = TRUE)

# calculate some numbers for the email
wdrs_complete <- running_list_updated %>% filter(WDRS_complete==1)%>%distinct(SEQUENCE_ACCESSION)
wdrs_incomplete <- running_list_updated %>% filter(WDRS_complete==0)%>%distinct(SEQUENCE_ACCESSION)
keep_na <- running_list_updated %>% filter(WDRS_complete==0 & keep_na==1 )%>%distinct(SEQUENCE_ACCESSION)

pending_roster <- (nrow(roster_final_duplicates) + nrow(single_error_to_write_roster_here))
manual_review_total <- (nrow(wdrs_incomplete) - pending_roster - nrow(keep_na))
                           
# Output updated list                           
write.csv(running_list_updated, file.path(paste0("")), na="",row.names = FALSE)


```


# Send email that script is completed - Will need to adjust for data support TBD
```{r}
# Send email with review results

  email_from <- ""
  email_to <- ""
  email_subj <- "Sequencing - For_Review Completed Automated Email"
  
  email_body <- paste(
  "Sent to write_roster_here: \n \n",
  (nrow(roster_final_duplicates)), "duplicate records resolved and sent to write_roster_here.\n",
  (nrow(single_error_to_write_roster_here)), "single error records resolved and sent to write_roster_here.\n \n",
  "Sent to manual review: \n \n",
  (nrow(manual_review)), "duplicate records sent to manual review.\n", 
  (nrow(single_error_manual_review)), "single error records sent to manual review.\n", 
  (nrow(multiple_errors)), "multiple error records sent to manual review.\n \n",
  "Overview: \n \n",
  (nrow(new_records)), "unique records added to for_review running list.\n",
  (pending_roster), "records pending roster. \n",
  (manual_review_total), "records pending manual review. \n",
  (nrow(wdrs_complete)), "records completed to date.\n"
  
  )

# send it
sendmailR::sendmail(from = email_from,
                    to = email_to,
                    subject = email_subj,
                    msg = email_body,
                    headers= list("Reply-To" = email_from),
                    control = list(smtpServer = ""))


```
